---
title: Unidad 5
unitId: unit5
---

import { Aside } from '@astrojs/starlight/components';

## Introducci√≥n üìú

En esta unidad vas a profundizar en los principios fundamentales de la Programaci√≥n Orientada a Objetos (OOP) usando C++. El objetivo 
es profundo: no solo usar√°s la herencia, el polimorfismo y el encapsulamiento en C++, sino que entender√°s c√≥mo funcionan por dentro, "bajo el cap√≥". 
Este conocimiento es lo que te permitir√°, en el futuro, aprender cualquier otro lenguaje orientado a objetos, 
porque sabr√°s qu√© buscar y c√≥mo funcionan los principios fundamentales.

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

Reconozco que cada uno de ustedes llega a este punto con un bagaje distinto. Algunos se han dado por vencidos con la programaci√≥n,
otros han tenido experiencias frustrantes, y algunos han podido aprender. Por eso, en esta unidad, t√∫ eliges el trayecto de 
aprendizaje. Te propongo dos rutas:

<Aside type="tip">
La ruta guiada: un camino estructurado con actividades paso a paso que te llevar√°n a trav√©s de todos los conceptos 
clave usando arte generativo. Es ideal si prefieres tener una gu√≠a clara y un objetivo definido.
</Aside>

<Aside type="tip">
La ruta de exploraci√≥n personal: un camino para los curiosos, para los que quieren ir a su propio ritmo, profundizar en lo que m√°s les 
interesa o **reforzar lo que m√°s necesitan**. Aqu√≠, el objetivo no es completar una lista de tareas, sino 
embarcarte en una investigaci√≥n personal. ES UNA NUEVA OPORTUNIDAD para reconciliarte con la programaci√≥n y descubrir su belleza.
</Aside>

**¬øEn qu√© consiste la ruta de exploraci√≥n personal?**

Tu misi√≥n es la misma: desentra√±ar los secretos de la OOP usando C++ como medio. Pero t√∫ decides el mapa. El punto de partida es un diagn√≥stico.  
Realizar√°s una breve actividad inicial. No es una prueba, es un espejo que te ayudar√° a ver qu√© conceptos manejas bien y cu√°les son √°reas de oportunidad.  
Luego t√∫ defines, basado en tu diagn√≥stico, tus propias preguntas. ¬øQu√© te genera m√°s curiosidad? ¬øQu√© necesitas reforzar? Dise√±ar√°s tus experimentos 
actuando como un cient√≠fico computacional. Crear√°s peque√±os programas, usar√°s el depurador y buscar√°s la evidencia que responda a tus preguntas.  **ES MUY IMPORTANTE** 
que sepas que en cualquiera de las dos rutas el error no es un fracaso, sino un dato valioso. No estamos apostando por el resultado final, sino por el proceso de aprendizaje.  
Cada error es una oportunidad para aprender y crecer. Documenta tu Viaje en tu bit√°cora de aprendizaje, registrar√°s tu proceso. Una buena bit√°cora no solo 
muestra c√≥digo, muestra pensamiento: tus preguntas, hip√≥tesis, experimentos (con capturas de pantalla), hallazgos, y reflexiones.


<Aside type="caution">
**¬øC√≥mo ser√° la evaluaci√≥n?**

Tu calificaci√≥n sumativa se basa 100% en tu bit√°cora de aprendizaje. Al final, esta deber√° incluir una secci√≥n de autoevaluaci√≥n donde 
**t√∫ mismo propondr√°s una nota** de 0 a 5, justific√°ndola de manera detallada con la r√∫brica y apuntando a las evidencias concretas dentro de tu propia bit√°cora.

Tendremos una conversaci√≥n final, pero no es un examen es una conversaci√≥n 100% formativa. Ser√° un espacio para que dialoguemos sobre tu aprendizaje, 
tus descubrimientos y desaf√≠os, y para que yo pueda darte feedback personalizado. Llegar√°s a esa conversaci√≥n con la tranquilidad de que tu evaluaci√≥n 
ya est√° plasmada en tu trabajo escrito.

Ten presente que la ruta de exploraci√≥n personal no es un camino f√°cil. Es una ruta que exige autonom√≠a y curiosidad.
</Aside>

## Seek: Investigaci√≥n üîé

### Actividad 01 

Esta ser√° nuestra actividad de diagn√≥stico inicial

**Parte 1: recordando los conceptos (en C#)**

En tus cursos anteriores has trabajado principalmente con C#. Bas√°ndote en esa experiencia, responde con tus propias palabras:

1. ¬øQu√© es el encapsulamiento para ti? Describe una situaci√≥n en la que te haya sido √∫til o donde hayas visto su importancia.  
2. ¬øQu√© es la herencia? ¬øPor qu√© un programador decidir√≠a usarla? Da un ejemplo simple.  
3. ¬øQu√© es el polimorfismo? Describe con tus palabras qu√© significa que un c√≥digo sea "polim√≥rfico".  

**Parte 2: an√°lisis de c√≥digo (en C#)**

``` csharp
using System;
using System.Collections.Generic;

public abstract class Figura
{
    private string nombre;

    public string Nombre
    {
        get { return nombre; }
        protected set { nombre = value; } 
    }

    public Figura(string nombre)
    {
        this.Nombre = nombre;
    }

    public abstract void Dibujar();
}

public class Circulo : Figura
{
    public double Radio { get; private set; }

    public Circulo(double radio) : base("C√≠rculo")
    {
        this.Radio = radio;
    }

    public override void Dibujar()
    {
        Console.WriteLine($"Dibujando un {Nombre} de radio {Radio}.");
    }
}

public class Rectangulo : Figura
{
    public double Base { get; private set; }
    public double Altura { get; private set; }

    public Rectangulo(double b, double h) : base("Rect√°ngulo")
    {
        this.Base = b;
        this.Altura = h;
    }

    public override void Dibujar()
    {
        Console.WriteLine($"Dibujando un {Nombre} de {Base}x{Altura}.");
    }
}

public class Programa
{
    public static void Main()
    {
        List<Figura> misFiguras = new List<Figura>();

        misFiguras.Add(new Circulo(5.0));
        misFiguras.Add(new Rectangulo(4.0, 6.0));
        misFiguras.Add(new Circulo(10.0));

        foreach (Figura fig in misFiguras)
        {
            fig.Dibujar();
        }
    }
}
```

Ahora, responde a estas preguntas sobre el c√≥digo:

**Encapsulamiento:**
* Se√±ala una l√≠nea de c√≥digo que sea un ejemplo claro de encapsulamiento y explica por qu√© lo es.
* ¬øPor qu√© crees que el campo nombre es private pero la propiedad Nombre es public? ¬øQu√© problema se evita con esto?

**Herencia:**
* ¬øC√≥mo se evidencia la herencia en la clase Circulo?
* Un objeto de tipo Circulo, adem√°s de Radio, ¬øQu√© otros datos almacena en su interior gracias a la herencia?

**Polimorfismo:**
* Observa el bucle foreach. La variable fig es de tipo Figura, pero a veces contiene un Circulo y otras un Rectangulo. 
Cuando se llama a fig.Dibujar(), el programa ejecuta la versi√≥n correcta. En tu opini√≥n, ¬øC√≥mo crees que funciona esto 
"por debajo"? No necesitas saber la respuesta correcta, solo quiero que intentes razonar c√≥mo podr√≠a ser.

**Parte 3: hip√≥tesis sobre la implementaci√≥n**

Esta es la parte m√°s importante. Imagina que eres un dise√±ador de lenguajes de programaci√≥n. Tienes que decidir c√≥mo 
implementar estos conceptos en la memoria y en el procesador. No hay respuestas incorrectas, solo ideas. Dibuja si te ayuda.

1. Memoria y herencia: cuando creas un objeto Rectangulo, este tiene Base, Altura y tambi√©n Nombre. ¬øC√≥mo te imaginas que se 
organizan esos tres datos en la memoria del computador para formar un solo objeto?

2. El mecanismo del polimorfismo: pensemos de nuevo en la llamada fig.Dibujar(). El compilador solo sabe que fig es una Figura. 
¬øC√≥mo decide el programa, mientras se est√° ejecutando, si debe llamar al Dibujar del Circulo o al del Rectangulo? Lanza algunas 
ideas o hip√≥tesis.

3. La barrera del encapsulamiento: ¬øC√≥mo crees que el compilador logra que no puedas acceder a un miembro private desde fuera 
de la clase? ¬øEs algo que se revisa cuando escribes el c√≥digo, o es una protecci√≥n que existe mientras el programa se ejecuta? 
¬øPor qu√© piensas eso?

**Parte 4: y tu autoevaluaci√≥n y primeras preguntas**

Has completado el diagn√≥stico. Ahora, reflexiona sobre tu propia experiencia y basado en esto te propongo dos caminos:

1. Formula la primer pregunta que comenzar√°s a investigar. Este ser√° el punto de partida para tu "ruta de exploraci√≥n personal". 
Tu vas definiendo tus propiuas actividades.
2. Si prefieres la "ruta guiada" adelante. Comienza con la actividad 2.

### Actividad 02 

En esta actividad te mostrar√© una aplicaci√≥n para que veas aplicados todos los conceptos que estudiar√°s en esta unidad. 

Durante la actividad te indicar√© los momentos en los que debes detenerte para analizar üßê, experimentar üß™ y reportar ‚úçÔ∏è tus hallazgos en la bit√°cora de 
aprendizaje.

Crea un proyecto en openFrameworks y adiciona el siguiente c√≥digo.

ofApp.h

``` cpp
#pragma once
#include "ofMain.h"
#include <vector>

// -------------------------------------------------
// Clase base abstracta: Particle
// -------------------------------------------------
class Particle {
public:
    virtual ~Particle() {}
    virtual void update(float dt) = 0;
    virtual void draw() = 0;
    virtual bool isDead() const = 0;
    // Nuevo m√©todo para saber si la part√≠cula (tipo RisingParticle) debe explotar
    virtual bool shouldExplode() const { return false; }
    // M√©todos para obtener posici√≥n y color, para usarlos en explosiones
    virtual glm::vec2 getPosition() const { return glm::vec2(0, 0); }
    virtual ofColor getColor() const { return ofColor(255); }
};

// -------------------------------------------------
// RisingParticle: Part√≠cula que nace en la parte inferior central y sube
// -------------------------------------------------
class RisingParticle : public Particle {
protected:
    glm::vec2 position;
    glm::vec2 velocity;
    ofColor color;
    float lifetime; // tiempo m√°ximo antes de explotar
    float age;
    bool exploded;
public:
    RisingParticle(const glm::vec2& pos, const glm::vec2& vel, const ofColor& col, float life)
        : position(pos), velocity(vel), color(col), lifetime(life), age(0), exploded(false) {
    }

    void update(float dt) override {
        position += velocity * dt;
        age += dt;
        // Aumenta la desaceleraci√≥n para dar sensaci√≥n de recorrido largo
        velocity.y += 9.8f * dt * 8;
        // Condici√≥n de explosi√≥n: cuando la part√≠cula alcanza aproximadamente el 15% de la altura
        float explosionThreshold = ofGetHeight() * 0.15 + ofRandom(-30, 30);
        if (position.y <= explosionThreshold || age >= lifetime) {
            exploded = true;
        }
    }

    void draw() override {
        ofSetColor(color);
        // Part√≠cula m√°s grande
        ofDrawCircle(position, 10);
    }

    bool isDead() const override { return exploded; }
    bool shouldExplode() const override { return exploded; }
    glm::vec2 getPosition() const override { return position; }
    ofColor getColor() const override { return color; }
};

// -------------------------------------------------
// Clase base para explosiones: ExplosionParticle
// -------------------------------------------------
class ExplosionParticle : public Particle {
protected:
    glm::vec2 position;
    glm::vec2 velocity;
    ofColor color;
    float age;
    float lifetime;
    float size;  // tama√±o de la part√≠cula de explosi√≥n
public:
    ExplosionParticle(const glm::vec2& pos, const glm::vec2& vel, const ofColor& col, float life, float sz)
        : position(pos), velocity(vel), color(col), age(0), lifetime(life), size(sz) {
    }

    void update(float dt) override {
        position += velocity * dt;
        age += dt;
        float alpha = ofMap(age, 0, lifetime, 255, 0, true);
        color.a = alpha;
    }

    bool isDead() const override { return age >= lifetime; }
};

// -------------------------------------------------
// CircularExplosion: Explosi√≥n en patr√≥n circular
// -------------------------------------------------
class CircularExplosion : public ExplosionParticle {
public:
    CircularExplosion(const glm::vec2& pos, const ofColor& col)
        : ExplosionParticle(pos, glm::vec2(0, 0), col, 1.2f, ofRandom(16, 32)) {
        float angle = ofRandom(0, TWO_PI);
        float speed = ofRandom(80, 200);
        velocity = glm::vec2(cos(angle), sin(angle)) * speed;
    }

    void draw() override {
        ofSetColor(color);
        ofDrawCircle(position, size);
    }
};

// -------------------------------------------------
// RandomExplosion: Explosi√≥n con direcciones aleatorias
// -------------------------------------------------
class RandomExplosion : public ExplosionParticle {
public:
    RandomExplosion(const glm::vec2& pos, const ofColor& col)
        : ExplosionParticle(pos, glm::vec2(0, 0), col, 1.5f, ofRandom(16, 32)) {
        velocity = glm::vec2(ofRandom(-200, 200), ofRandom(-200, 200));
    }

    void draw() override {
        ofSetColor(color);
        ofDrawRectangle(position.x, position.y, size, size);
    }
};

// -------------------------------------------------
// StarExplosion: Explosi√≥n en forma de estrella
// -------------------------------------------------
class StarExplosion : public ExplosionParticle {
public:
    StarExplosion(const glm::vec2& pos, const ofColor& col)
        : ExplosionParticle(pos, glm::vec2(0, 0), col, 1.3f, ofRandom(20, 40)) {
        float angle = ofRandom(0, TWO_PI);
        float speed = ofRandom(90, 180);
        velocity = glm::vec2(cos(angle), sin(angle)) * speed;
    }

    void draw() override {
        ofSetColor(color);
        int rays = 5;
        float outerRadius = size;
        float innerRadius = size * 0.5;
        ofPushMatrix();
        ofTranslate(position);
        for (int i = 0; i < rays; i++) {
            float theta = ofMap(i, 0, rays, 0, TWO_PI);
            float xOuter = cos(theta) * outerRadius;
            float yOuter = sin(theta) * outerRadius;
            float xInner = cos(theta + PI / rays) * innerRadius;
            float yInner = sin(theta + PI / rays) * innerRadius;
            ofDrawLine(0, 0, xOuter, yOuter);
            ofDrawLine(xOuter, yOuter, xInner, yInner);
        }
        ofPopMatrix();
    }
};

// -------------------------------------------------
// ofApp: Manejo de la escena y eventos
// -------------------------------------------------
class ofApp : public ofBaseApp {
public:
    void setup();
    void update();
    void draw();
    void mousePressed(int x, int y, int button);
	void keyPressed(int key);

    std::vector<Particle*> particles;
    ~ofApp();

private:
	void createRisingParticle();

};

``` 

ofApp.cpp

``` cpp
#include "ofApp.h"

// --------------------------------------------------------------
void ofApp::setup() {
    ofSetFrameRate(60);
    ofBackground(0);
}

// --------------------------------------------------------------
void ofApp::update() {
    float dt = ofGetLastFrameTime();

    // Actualiza todas las part√≠culas
    for (int i = 0; i < particles.size(); i++) {
        particles[i]->update(dt);
    }

    // Procesa las part√≠culas (iteraci√≥n en reversa para facilitar eliminaci√≥n)
    for (int i = particles.size() - 1; i >= 0; i--) {
        // Si la part√≠cula debe explotar, generamos nuevas explosiones
        if (particles[i]->shouldExplode()) {
            int explosionType = (int)ofRandom(3); // 0: Circular, 1: Random, 2: Star
            int numParticles = (int)ofRandom(20, 30);
            for (int j = 0; j < numParticles; j++) {
                if (explosionType == 0) {
                    particles.push_back(new CircularExplosion(particles[i]->getPosition(), particles[i]->getColor()));
                }
                else if (explosionType == 1) {
                    particles.push_back(new RandomExplosion(particles[i]->getPosition(), particles[i]->getColor()));
                }
                else {
                    particles.push_back(new StarExplosion(particles[i]->getPosition(), particles[i]->getColor()));
                }
            }
            delete particles[i];
            particles.erase(particles.begin() + i);
        }
        else if (particles[i]->isDead()) {
            delete particles[i];
            particles.erase(particles.begin() + i);
        }
    }
}

// --------------------------------------------------------------
void ofApp::draw() {
    for (int i = 0; i < particles.size(); i++) {
        particles[i]->draw();
    }
}

// --------------------------------------------------------------
void ofApp::createRisingParticle() {
	// Genera una RisingParticle cerca del centro inferior (con variaci√≥n horizontal)
	float minX = ofGetWidth() * 0.35;
	float maxX = ofGetWidth() * 0.65;
	float spawnX = ofRandom(minX, maxX);
	glm::vec2 pos(spawnX, ofGetHeight());
	// La part√≠cula apunta hacia un objetivo en la parte superior central
	glm::vec2 target(ofGetWidth() / 2 + ofRandom(-300, 300), ofGetHeight() * 0.10 + ofRandom(-30, 30));
	glm::vec2 direction = glm::normalize(target - pos);
	// Velocidad ajustada para recorrer una mayor distancia
	glm::vec2 vel = direction * ofRandom(250, 350);
	ofColor col;
	col.setHsb(ofRandom(255), 220, 255);
	float lifetime = ofRandom(1.5, 3.5); // Tiempo de vida antes de explotar
	particles.push_back(new RisingParticle(pos, vel, col, lifetime));
}

// --------------------------------------------------------------
void ofApp::mousePressed(int x, int y, int button) {
    createRisingParticle();
}

// --------------------------------------------------------------
void ofApp::keyPressed(int key) {
	if (key == ' ') {
		for (int i = 0; i < 1000; i++) {
			createRisingParticle();
		}
	}
    if (key == 's') {
        ofSaveScreen("screenshot_" + ofToString(ofGetFrameNum()) + ".png");
    }
}

// --------------------------------------------------------------
ofApp::~ofApp() {
    for (int i = 0; i < particles.size(); i++) {
        delete particles[i];
    }
    particles.clear();
}
```

üßêüß™‚úçÔ∏è Analiza el c√≥digo de la aplicaci√≥n y trata de explicar en tus propias palabras qu√© est√° haciendo, NO USES IA generativa. Captura 
pantallas de la aplicaci√≥n funcionando y a√±√°delas a la bit√°cora de aprendizaje.

Cuando ejecutes la aplicaci√≥n deber√≠as ver algo como esto:

![Una part√≠cula](../../../assets/u5a1-1.webp)  

![Una part√≠cula- explosi√≥n](../../../assets/u5a1-2.webp)

![M√∫ltiples part√≠culas](../../../assets/u5a1-3.webp)

![M√∫ltiples part√≠culas- explosi√≥n](../../../assets/u5a1-4.webp)

### Actividad 03

Ahora te guiar√© en el an√°lisis del caso de estudio anterior. En esta actividad 
vas a recordar y sobre todo a ``redescubrir`` algunos conceptos fundamentales de la programaci√≥n orientada a objetos, pero 
esta vez lo har√°s desde la experimentaci√≥n y la curiosidad. Quiero insistir en esto. En cursos previos ya abordaste te√≥ricamente estos conceptos e 
incluso los aplicaste en ejercicios pr√°cticos. Sin embargo, en esta actividad vas a experimentar con el caso de estudio y con el depurador de c√≥digo para 
que puedas comprender mejor c√≥mo se comportan los objetos en un programa y c√≥mo se implementan algunos conceptos como la herencia, el polimorfismo y 
el encapsulamiento.

**Concepto de objeto**: en la programaci√≥n orientada a objetos, un objeto 
es una instancia de una clase. Una clase define un tipo de objeto, pero **no** 
es un objeto en s√≠ mismo. Pero ¬øC√≥mo se ve un objeto en la memoria? 

Considera el caso de estudio. Usa el depurador para encontrar la instancia 
de la clase ofApp. Recuerda que debes usar el depurador porque ``el objeto 
solo estar√° en la memoria mientras la aplicaci√≥n est√© corriendo``.

Antes de comenzar el experimento observa la clase ofApp:


``` cpp
class ofApp : public ofBaseApp {
public:
    void setup();
    void update();
    void draw();
    void mousePressed(int x, int y, int button);
    void keyPressed(int key);

    std::vector<Particle*> particles;
    ~ofApp();

private:
    void createRisingParticle();

};
```

üßêüß™‚úçÔ∏è Antes de ejecutar el experimento, ¬øQu√© esperas ver en memoria (hip√≥tesis)? Ejecuta el c√≥digo y muestra una captura 
de pantalla del objeto en la memoria. ¬øQu√© puedes observar? ¬øQu√© informaci√≥n te proporciona el depurador? ¬øQu√© puedes concluir?

üßêüß™‚úçÔ∏è Usa de nuevo el depurador para capturar un objeto de tipo ``CircularExplosion``. Es posible que tengas que hacer 
modificaciones m√≠nimas en el c√≥digo para que puedas capturar este objeto m√°s f√°cilmente. Observa con el depurador la ventana 
de Auto o Locals y la ventana de Memory 1. Trata de buscar en memoria todas las partes que componen al objeto tipo ``CircularExplosion`` 
¬øQu√© puedes observar en la memoria? ¬øQu√© informaci√≥n te proporciona el depurador? ¬øQu√© puedes concluir? NO OLVIDES tener a la mano todas 
la jerarqu√≠a de clases que componen a ``CircularExplosion``. De esta manera podr√°s identificar cada parte del objeto en memoria.


**Concepto de los m√©todos virtuales**: observa de nuevo en memoria un objeto de tipo ``CircularExplosion``. Nota que el primer campo en memoria del objeto 
es un ``ExplosionParticle``. Abren el objeto ``ExplosionParticle`` y observa que el primer campo en memoria es un ``Particle``. Abre el objeto ``Particle``
y observa que el primer campo en memoria es ``_vtable``. ¬øQu√© es eso? Es un puntero a una tabla de funciones virtuales. Observa detenidamente la tabla de funciones. 

üßêüß™‚úçÔ∏è Captura la _vtable de un objeto ``CircularExplosion``, pega la imagen en tu bit√°cora, pero observa detenidamente la tabla de funciones. ¬øQu√© puedes observar?

Te voy a mostrar un ejemplo, en mi caso, de c√≥mo se ve la tabla de funciones:

![vtable CircularExplosion](../../../assets/u5a2-1.png)

üßêüß™‚úçÔ∏è Ahora, captura en memoria la _vtable de un objeto ``StarExplosion``, 
pega la imagen en tu bit√°cora y observa detenidamente la tabla de funciones.

Te muestro de nuevo el ejemplo, en mi caso, de c√≥mo se ve la tabla de funciones:

![vtable StarExplosion](../../../assets/u5a2-2.png)


üßêüß™‚úçÔ∏è Observa de nuevo ambas tablas y compara. ¬øQu√© puedes ver? 
¬øQu√© puedes concluir? ¬øQu√© relaci√≥n existe entre la tabla de funciones 
y los m√©todos virtuales? Esta pregunta que te voy a hacer no es f√°cil y la idea 
de hacerla es prepararte mentalmente para lo viene ¬øPara qu√© crees que 
pueda servir una tabla de funciones virtuales? Para responder esta pregunta 
trata de pensar en el polimorfismo con interfaces y clases abstractas que viste 
al estudiar C#, por ejemplo, con interfaces:

``` csharp
using System;

interface IAnimal
{
    void HacerSonido();
}

class Perro : IAnimal
{
    public void HacerSonido()
    {
        Console.WriteLine("El perro ladra: ¬°Guau, guau!");
    }
}

class Gato : IAnimal
{
    public void HacerSonido()
    {
        Console.WriteLine("El gato ma√∫lla: ¬°Miau, miau!");
    }
}

class Program
{
    static void Main()
    {
        // Polimorfismo: Usamos la interfaz para tratar diferentes tipos de animales
        IAnimal[] animales = new IAnimal[]
        {
            new Perro(),
            new Gato()
        };

        foreach (IAnimal animal in animales)
        {
            animal.HacerSonido(); // Llamada polim√≥rfica
        }
    }
}
```

Nota que el m√©todo ``HacerSonido`` se llama dos veces, una vez para 
el perro y otra vez para el gato. ¬øC√≥mo se logra esto? ¬øQu√© relaci√≥n 
existe entre los m√©todos virtuales y el polimorfismo? Al llamar ``HacerSonido`` 
c√≥mo sabe esta funci√≥n sobre cu√°l objeto debe actuar?

Dejemos por ahora este experimento hasta este punto, pero un rato lo vamos retomar. 

### Actividad 04

**Concepto de encapsulamiento**: el encapsulamiento es un concepto fundamental 
en la programaci√≥n orientada a objetos. En C++ el encapsulamiento se logra 
mediante el uso de modificadores de acceso. Te voy a proponer un experimento que 
puedes implementar creando un proyecto de consola de C++ en Visual Studio. 

``` cpp
class AccessControl {

private:
    int privateVar;

protected:
    int protectedVar;

public:
    int publicVar;
    AccessControl() : privateVar(1), protectedVar(2), publicVar(3) {}
};

int main() {
    AccessControl ac;
    ac.publicVar = 10; // V√°lido
    // ac.protectedVar = 20; // Error de compilaci√≥n
    // ac.privateVar = 30; // Error de compilaci√≥n
    return 0;
}
```

Ejecuta este c√≥digo. Luego, descomenta las l√≠neas que est√°n comentadas y 
vuelve a compilar. ¬øQu√© sucede? ¬øPor qu√© sucede esto? ¬øQu√© puedes concluir? 

Ahora quiero que notes algo. El encapsulamiento solo lo podemos garantizar en 
tiempo de compilaci√≥n. Sin embargo, en tiempo de ejecuci√≥n podemos acceder a 
los campos privados de un objeto. Analiza el siguiente programa:

``` cpp
#include <iostream>

class MyClass {
private:
    int secret1;
    float secret2;
    char secret3;

public:
    MyClass(int s1, float s2, char s3) : secret1(s1), secret2(s2), secret3(s3) {}

    void printMembers() const {
        std::cout << "secret1: " << secret1 << "\n";
        std::cout << "secret2: " << secret2 << "\n";
        std::cout << "secret3: " << secret3 << "\n";
    }
};


int main() {
    MyClass obj(42, 3.14f, 'A');
    // Esta l√≠nea causar√° un error de compilaci√≥n
    std::cout << obj.secret1 << std::endl;

    obj.printMembers();  // M√©todo p√∫blico para mostrar los valores
    return 0;
}
```

üßêüß™‚úçÔ∏è Compila el programa. ¬øQu√© pasa?

Ahora prueba con este programa:

``` cpp	
#include <iostream>

class MyClass {
private:
    int secret1;
    float secret2;
    char secret3;

public:
    MyClass(int s1, float s2, char s3) : secret1(s1), secret2(s2), secret3(s3) {}

    void printMembers() const {
        std::cout << "secret1: " << secret1 << "\n";
        std::cout << "secret2: " << secret2 << "\n";
        std::cout << "secret3: " << secret3 << "\n";
    }
};

int main() {
    MyClass obj(42, 3.14f, 'A');

    // Usando reinterpret_cast para violar el encapsulamiento
    int* ptrInt = reinterpret_cast<int*>(&obj);
    float* ptrFloat = reinterpret_cast<float*>(ptrInt + 1);
    char* ptrChar = reinterpret_cast<char*>(ptrFloat + 1);

    // Accediendo y mostrando los valores privados
    std::cout << "Accediendo directamente a los miembros privados:\n";
    std::cout << "secret1: " << *ptrInt << "\n";       // Accede a secret1
    std::cout << "secret2: " << *ptrFloat << "\n";     // Accede a secret2
    std::cout << "secret3: " << *ptrChar << "\n";      // Accede a secret3

    return 0;
}
```

üßêüß™‚úçÔ∏è Compila el programa y ejecuta. ¬øQu√© puedes concluir?

üßêüß™‚úçÔ∏è En tus palabras, ¬øQu√© es el encapsulamiento? ¬øPor qu√© es importante? 

### Actividad 05

**Concepto de herencia**: la herencia es otro concepto fundamental en la programaci√≥n 
orientada a objetos. Observa de nuevo en ofApp.h la clase ``CircularExplosion``. Observa 
que esta clase hereda de la clase ``ExplosionParticle`` que a su vez hereda de la clase 
``Particle``. 

üßêüß™‚úçÔ∏è captura de nuevo la memoria que ocupa el objeto ``CircularExplosion`` compara 
la jerarqu√≠a de clases con los campos en memoria del objeto. ¬øQu√© puedes observar? 
¬øQu√© informaci√≥n te proporciona el depurador? ¬øQu√© puedes concluir?

üßêüß™‚úçÔ∏è ¬øC√≥mo se implementa la herencia en C++?

üßêüß™‚úçÔ∏è C++ permite hacer algo que C# no: herencia m√∫ltiple. Realiza un experimento 
que te permita ver c√≥mo se objeto en memoria cuya clase base tiene herencia m√∫ltiple.


### Actividad 06

**Concepto de polimorfismo**: recuerdas que ya analizaste el concepto de los m√©todos 
virtuales y su relaci√≥n con la tabla de funciones virtuales. Ahora quiero que pienses 
en el polimorfismo. 

Observa en ofApp.cpp en el m√©todo ``update()`` esta parte del c√≥digo:

``` cpp
    // Actualiza todas las part√≠culas
    for (int i = 0; i < particles.size(); i++) {
        particles[i]->update(dt);
    }
```

el m√©todo update de la clase ``Particle`` es un m√©todo virtual. Usa el depurador 
para analizar c√≥mo se comporta este m√©todo en tiempo de ejecuci√≥n. Realiza 
esta verificaci√≥n cuando particles tenga varios objetos de diferentes tipos 
de part√≠culas. ¬øQu√© puedes observar? ¬øQu√© informaci√≥n te proporciona el depurador?

Nota que update se comporta de manera diferente para cada tipo de part√≠cula. A esto 
se le llama polimorfismo en tiempo de ejecuci√≥n.

üßêüß™‚úçÔ∏è Realiza un dibujo con el cu√°l expliques c√≥mo se implementa el polimorfismo 
en tiempo de ejecuci√≥n. Utiliza el concepto de m√©todos virtuales y la tabla de funciones 
virtuales. ¬øQu√© puedes concluir? 

üßêüß™‚úçÔ∏è ¬øQu√© relaci√≥n existe entre los m√©todos virtuales y el polimorfismo?

## Apply: Aplicaci√≥n üõ†

### Actividad 07

Aplica lo aprendido. Vas a evaluar lo aprendido en la fase anterior modificando el caso 
de estudio.

‚ö†Ô∏è **IMPORTANTE**: si usas IA generativa no le pidas respuestas. La idea de esta secci√≥n es que 
apliques lo aprendido. Si no sabes c√≥mo hacerlo, quiere decir que a√∫n tienes vac√≠os en tu aprendizaje 
y debes regresar a la fase anterior o solicitar ayuda al profesor antes de continuar.

**¬øQu√© har√°s?**

1. Agrega dos nuevos tipos de Particle diferentes a **RisingParticle**.  
2. Implementar un nuevo modo de explosi√≥n.

Reporta en tu bit√°cora de aprendizaje: 

1. ¬øC√≥mo y por qu√© de la implementaci√≥n de cada una de las extensiones solicitadas al caso de estudio?
2. ¬øC√≥mo y por qu√© de la implementaci√≥n de los conceptos de encapsulamiento, herencia y polimorfismo en tu c√≥digo?
3. Explica c√≥mo verificaste que cada una de las extensiones funciona correctamente, muestra capturas de pantalla del depurador 
donde evidencias lo anterior, en particular el polimorfismo en tiempo de ejecuci√≥n.

## Evidencias üóÇÔ∏è

<Aside type="note" title="RUBRICA!">
* Recuerda que la bit√°cora se cierra el 18 de septiembre de 2025 a las 7:49 a.m. No olvides que el aprendizaje es un proceso que se 
plasma en la bit√°cora. La bit√°cora no es un resultado que se llena a √∫ltima hora.
* Si no realizas la secci√≥n de consolidaci√≥n, autoevaluaci√≥n y cierre, tu nota ser√° 0.

**R√∫brica de evaluaci√≥n del proceso**

| Criterio | **Inicial (0.0 - 1.9)** | **En desarrollo (2.0 - 3.4)** | **Logrado (3.5 - 4.4)** | **Excelente (4.5 - 5.0)** |
| :--- | :--- | :--- | :--- | :--- |
| **1. Profundidad de la Indagaci√≥n** | Las preguntas son superficiales o ausentes. No se define una direcci√≥n clara para la exploraci√≥n. | Se formulan preguntas relevantes, pero se enfocan principalmente en el "qu√©" y el "c√≥mo" de los conceptos de manera aislada. | Se formulan preguntas que **conectan** los conceptos (ej. "¬øC√≥mo se relaciona la herencia con la vtable?"). La investigaci√≥n sigue una l√≠nea l√≥gica y demuestra una intenci√≥n clara de entender los mecanismos. | Se formulan preguntas que demuestran una **s√≠ntesis** conceptual. Las preguntas exploran el **"porqu√©" del dise√±o** y las interdependencias (ej. "¬øC√≥mo garantiza el encapsulamiento la integridad del polimorfismo a nivel de la vtable?"). |
| **2. Calidad de la Experimentaci√≥n** | Los experimentos son una simple ejecuci√≥n del c√≥digo base, sin modificaciones ni an√°lisis. | Se realizan modificaciones sencillas al c√≥digo y se usa el depurador para observar valores, pero sin un an√°lisis sistem√°tico. | Se dise√±an y ejecutan experimentos **efectivos** para verificar el funcionamiento de cada concepto (herencia, polimorfismo, encapsulamiento). Se usa el depurador de forma correcta para recolectar evidencia. | Se dise√±an experimentos **precisos y elegantes** que no solo verifican el funcionamiento, sino que **a√≠slan y demuestran** las implicaciones y sutilezas de la interacci√≥n entre los conceptos. El uso del depurador es experto y sirve para construir argumentos s√≥lidos. |
| **3. An√°lisis y Reflexi√≥n** | La bit√°cora es un registro de acciones sin an√°lisis. Las conclusiones son incorrectas o no est√°n respaldadas por evidencia. | La bit√°cora describe los resultados de los experimentos, pero la reflexi√≥n es superficial. Se identifican los conceptos, pero no se explican con profundidad. | La bit√°cora **conecta claramente la evidencia** de los experimentos con la explicaci√≥n te√≥rica de cada concepto. Se analizan los errores como parte del aprendizaje y se llega a conclusiones correctas y bien fundamentadas. | La bit√°cora demuestra una **reflexi√≥n profunda** que va m√°s all√° de la simple verificaci√≥n. Se analiza **por qu√©** los mecanismos funcionan como lo hacen, se eval√∫an sus implicaciones en el dise√±o de software y se construye un **modelo mental coherente** que integra todos los hallazgos. |
| **4. Apropiaci√≥n y Articulaci√≥n de Conceptos** | La bit√°cora muestra una definici√≥n incorrecta o copiada de los conceptos. No se demuestra comprensi√≥n personal. | La bit√°cora explica los conceptos de forma b√°sica. La comprensi√≥n parece fragmentada y dependiente de la memorizaci√≥n. | La bit√°cora demuestra una **comprensi√≥n clara y correcta** de cada concepto por separado. Se utilizan palabras propias y analog√≠as adecuadas para explicar c√≥mo funciona la herencia, el polimorfismo y el encapsulamiento. | La bit√°cora demuestra una **maestr√≠a conceptual**. Se explican los conceptos como un **sistema interdependiente**. Se articula con total claridad y con lenguaje propio c√≥mo el encapsulamiento, la herencia y el polimorfismo colaboran para lograr el comportamiento orientado a objetos. La explicaci√≥n es robusta y transferible. |


</Aside>

<Aside type="danger" title="EVIDENCIAS EN BIT√ÅCORA">

**Estructura de la bit√°cora de aprendizaje**

Debe contener:

1.  **Diagn√≥stico inicial:** tus reflexiones sobre la actividad de diagn√≥stico.
2.  **Plan de exploraci√≥n:** la pregunta inicial que guiar√° tu trabajo, luego en el camino seguir√°s formulando m√°s preguntas.
3.  **Registro de exploraci√≥n:** el cuerpo principal de tu bit√°cora. Aqu√≠ documentas cada ciclo de pregunta -> hip√≥tesis -> experimento -> hallazgo -> reflexi√≥n. 
Debe ser rico en evidencia visual (c√≥digo, capturas del depurador con anotaciones, diagramas).
4.  **Consolidaci√≥n, autoevaluaci√≥n y cierre:** esta secci√≥n es OBLIGATORIA y central para tu evaluaci√≥n.


**Plantilla para la secci√≥n "Consolidaci√≥n, autoevaluaci√≥n y cierre"**

**1. Mi nota propuesta:** `[Escribe aqu√≠ la nota que te autoasignas]`

**2. Justificaci√≥n general:** escribe un p√°rrafo breve (5-7 l√≠neas) que resume por qu√© consideras que esta nota es justa, 
describiendo tu experiencia general, nivel de esfuerzo y principales aprendizajes.

**3. Mapeo de evidencias seg√∫n la r√∫brica:** para cada criterio de la r√∫brica, justifica tu nivel de logro y cita las evidencias espec√≠ficas de tu bit√°cora que respaldan tu afirmaci√≥n.

*   **Criterio 1: profundidad de la indagaci√≥n**
    *   **Mi autoevaluaci√≥n:** me sit√∫o en el nivel `[Indica el nivel]` porque...
    *   **Evidencias:** Ej: mis preguntas iniciales [p√°gina 2] eran sobre "qu√©", pero evolucionaron a preguntas sobre "por qu√©" como se ve en mi experimento sobre la vtable.

*   **Criterio 2: esfuerzo cognitivo y experimentaci√≥n**
    *   **Mi autoevaluaci√≥n:** considero que mi nivel es `[Indica el nivel]` porque...
    *   **Evidencias:** Ej: el dise√±o de mi experimento para "romper" el encapsulamiento demuestra que fui m√°s all√° de solo ejecutar el c√≥digo. La captura del depurador con mis notas es prueba de mi an√°lisis.

*   **Criterio 3: calidad del an√°lisis y la reflexi√≥n**
    *   **Mi autoevaluaci√≥n:** mi nivel aqu√≠ es `[Indica el nivel]` porque...
    *   **Evidencias:** Ej: mi reflexi√≥n sobre el error de compilaci√≥n no solo lo solucion√≥, sino que analic√© por qu√© ocurri√≥. Conect√© la teor√≠a con la pr√°ctica en mi 
    conclusi√≥n sobre la herencia.

*   **Criterio 4: apropiaci√≥n y articulaci√≥n de conceptos**
    *   **Mi autoevaluaci√≥n:** demuestro mi apropiaci√≥n en el nivel `[Indica el nivel]` porque...
    *   **Evidencias:** Ej: el diagrama que dibuj√© para explicar el polimorfismo y mi definici√≥n personal del concepto demuestran mi comprensi√≥n profunda y no memor√≠stica.
</Aside>

## Reflect: Consolidaci√≥n y metacognici√≥n ü§î

Es momento de hacer una de las fases m√°s importantes del aprendizaje: la reflexi√≥n.

1. En una hoja de papel o un white board digital te pedir√© que hagas un inventario de los 
conceptos de las unidades 1 a la 5. Luego construye un diagrama donde ubiques todos los conceptos tratando 
de agruparlos y relacionarlos entre s√≠. 
2. Preg√∫ntate: ¬øQu√© conceptos domino bien? ¬øCu√°les me cuestan m√°s trabajo?
3. Preg√∫ntate para qu√© pueden servirte estos conceptos.
4. ¬øQu√© hiciste bien en esta unidad que debes continuar haciendo?
5. ¬øQu√© deber√≠as comenzar a hacer para mejorar tu proceso?
6. Formula tu plan de acci√≥n personal para abordar aquello que te cueste m√°s trabajo.

