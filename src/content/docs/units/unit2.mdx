---
title: Unidad 2
unitId: unit2
---

## Introducci칩n 游닆

En esta unidad descubrir치s c칩mo se traducen algunos conceptos fundamentales de
la programaci칩n en alto nivel, como condicionales, ciclos, punteros y arreglos, 
a lenguaje ensamblador. Utilizar치s el lenguaje Hack de la unidad anterior 
para implementar estos conceptos. Esta unidad servir치 como puente para la siguiente 
unidad, donde exploraremos algunos conceptos fundamentales utilizando el lenguaje
de programaci칩n C++.

## Set: 쯈u칠 aprender치s en esta unidad? 游눠

En esta unidad aprender치s la relaci칩n entre el lenguaje ensamblador y un lenguaje de 
alto nivel como C++. Aprender치s a traducir conceptos de alto nivel a bajo nivel,
y viceversa. Adem치s, desarrollar치s programas que implementan estos conceptos en el
lenguaje ensamblador del computador Hack. Vas a explorar estos conceptos usando
el simulador del Hack. Y por favor, **SIEMPRE SIMULA** y aplica la metodolog칤a de
predice, ejecuta, observa y reflexiona.

### Actividad 01

#### Dibujando un punto en la pantalla

Vamos a resolver juntos este problema:

La pantalla del computador Hack se controla a trav칠s de un mapa de memoria que comienza en la direcci칩n 16384 (SCREEN). Cada bit en este mapa de memoria representa un pixel en la pantalla (1 = negro, 0 = blanco). Escribe un programa que dibuje un punto negro en la esquina superior izquierda de la pantalla. (Recuerda que la esquina superior izquierda corresponde al primer bit del primer word en la direcci칩n SCREEN).

Traduce este programa a lenguaje C++ para que relaciones c칩mo los conceptos de alto nivel se traducen a bajo nivel.

:::caution[游닋 Bit치cora] 
* Escribe tu mismo ambos programas.
* Simula paso a paso el programa en ensamblador. Recuerda la metodolog칤a: predice, ejecuta, observa y reflexiona.
:::

### Actividad 02

#### Dibujando una l칤nea horizontal

Vamos a resolver juntos este problema:

Modifica el programa anterior para que dibuje una l칤nea horizontal negra de 16 pixeles de largo en la esquina superior izquierda de la pantalla. (Recuerda que cada word en la memoria representa 16 pixeles).

Traduce este programa a lenguaje C++ para que relaciones c칩mo los conceptos de alto nivel se traducen a bajo nivel.

:::caution[游닋 Bit치cora] 
* Escribe tu mismo los programas.
* Simula paso a paso el programa ensamblador. Recuerda la metodolog칤a: predice, ejecuta, observa y reflexiona.
:::

### Actividad 03

#### Entrada salida interactiva

Modifica el programa de la actividad anterior de tal manera que puedas mover la l칤nea
horizontal de derecha a izquierda usando las teclas **d** y **i** respectivamente. Tu 
programa no tiene que verificar si la l칤nea se sale de la pantalla.

Traduce este programa a lenguaje C++ para que relaciones c칩mo los conceptos de alto nivel se traducen a bajo nivel.

:::caution[游닋 Bit치cora] 
* Escribe los programas.
* Simula paso a paso en lenguaje ensamblador. Recuerda la metodolog칤a: predice, ejecuta, observa y reflexiona.
:::


## Seek: Investigaci칩n 游댍

### Actividad 04

#### Convierte un ciclo while en un ciclo for

**Enunciado**: considera el siguiente programa: 

``` c
//Adds 1+...+100.
 int i=1;
 int sum=0;
 
 while(i <=100){
    sum+= i;
    i++;
 }
 ```

Una traducci칩n a ensamblador es como sigue: 

``` asm
// Adds1+...+100.
 @i // i refers to some memory location.
 M=1 // i=1
 @sum // sum refers to some memory location.
 M=0 // sum=0
 (LOOP)
 @i
 D=M // D=i
 @100
 D=D-A // D=i-100
 @END
 D;JGT // If(i-100)>0 gotoEND
 @i
 D=M // D=i
 @sum
 M=D+M // sum=sum+i
 @i
 M=M+1 // i=i+1
 @LOOP
 0;JMP // GotoLOOP
 (END)
 @END
 0;JMP // Infinite loop
```

Vamos a transformar este programa a su equivalente usando un ciclo for:

 ``` cpp
//Adds 1+...+100.
int sum=0;
for(int i = 1; i <=100; i++){
    sum+= i;
}
 ```

- Analiza los programas con while y for aseg칰rate de entender por qu칠 son equivalentes.
- Convierte la versi칩n del for a ensamblador.
- No olvides comprobar el funcionamiento de los programas en ensamblador en el simulador.
- Compara las versiones en ensamblador del while y del for. 쯈u칠 puedes concluir?

:::caution[游닋 Bit치cora] 
Escribe en tu bit치cora el programa en ensamblador y las conclusiones que has sacado de la comparaci칩n entre los dos programas.
:::


### Actividad 05

##### Punteros

Un puntero es una variable que almacena la direcci칩n de memoria de otra variable. Observa el siguiente programa escrito en C++:

``` cpp
int a = 10;
int* p;
p = &a;
*p = 20;
```

El programa anterior modifica el contenido de la variable **a** por medio de la variable **p**. **p** es un puntero porque almacena la direcci칩n de memoria de la variable **a**. En este caso el valor de la variable **a** ser치 20 luego de ejecutar *p = 20;. 

Ahora analiza con detenimiento:

- 쮺칩mo se **declara** un puntero en C++? 

``` cpp
int* p;
```

**p** es una variable que almacenar치 la direcci칩n de otra variable. Dicha variable almacenar치 n칰mero enteros.

- 쮺칩mo se **define** (nota que antes preguntamos c칩mo se **declara**) un puntero en C++? 

``` cpp
p = &a;. 
```

Definir el puntero es **inicializar** el valor del puntero, es decir, guardar la direcci칩n de una variable. En este caso p contendr치 la direcci칩n de a o podemos decir que p apunta a **a**

- 쮺칩mo se almacena en C++ la direcci칩n de memoria de una variable? Con el operador **&**. 

``` cpp
p = &a;
```

- 쮺칩mo se escribe el contenido de la variable a la que apunta un puntero? Con el operador *. 

``` cpp
*p = 20;
```

En este caso como **p** contiene la direcci칩n de **a**. Por tanto, se est치 modificando el valor 
de la variable **a** por medio de **p**.

Ahora vas a usar un puntero para leer la posici칩n de memoria a la que este apunta, 
es decir, vas a leer por medio del puntero la variable cuya direcci칩n est치 almacenada en 칠l.

``` cpp
int a = 10;
int b = 5;
int *p;
p = &a;
b = *p;
```

En este caso: 

``` cpp
b = *p;
```

el c칩digo anterior hace que el valor de b cambie de 5 a 10 porque p apunta a **a** y con *p a la derecha del igual est치s leyendo el contenido de la variable apuntada.


:::caution[游닋 Bit치cora]
Convierte estos programas a ensamblador y realiza la simulaci칩n paso a paso.
Recuerda la metodolog칤a: predice, ejecuta, observa y reflexiona.

``` cpp
int a = 10;
int* p;
p = &a;
*p = 20;
```

``` cpp
int a = 10;
int b = 5;
int *p;
p = &a;
b = *p;
```
:::

## Apply: Aplicaci칩n 游

### Actividad 06

#### Experimenta con arreglos

Los arreglos son colecciones de datos en la memoria. 

Considera el siguiente programa

``` cpp

int arr[] = {1,2,3,4,5,6,7,8,9,10};
int sum = 0;

for (int j = 0; j < 10; j++) {
    sum = sum + arr[j];
}

```

:::caution[游닋 Bit치cora]
- Implementa el programa anterior en lenguaje ensamblador aplicando el concepto de punteros.  
- Considera que los datos del arreglo est치n almacenados **desde** la direcci칩n 16. Inicializa 
el arreglo en lenguaje ensamblador.  
- Simula paso a paso el programa en ensamblador. Recuerda la metodolog칤a: predice, ejecuta, observa y reflexiona.  
- Construye tu programa PASO A PASO mediante pruebas. Indica qu칠 caracter칤stica vas 
a implementar con cada prueba y c칩mo la probaste.
- Muestra el programa final y c칩mo lo probaste. 
:::


## Reflect: Consolidaci칩n y metacognici칩n 游뱂

### Actividad 07

#### Autoevaluaci칩n

**Mirando hacia adentro: autoevaluaci칩n de conceptos y proceso**

El objetivo de esta actividad es que recuperes de tu memoria los conceptos que conectan la programaci칩n de alto nivel con el lenguaje ensamblador. Al forzarte a recordar sin ver tus notas (pr치ctica de recuperaci칩n), est치s fortaleciendo las conexiones neuronales de ese conocimiento. Adem치s, reflexionar치s sobre tu proceso para convertirte en un aprendiz m치s consciente y estrat칠gico.

:::caution[游닋 Bit치cora]
Sin consultar tus apuntes, c칩digo previo o el simulador, responde a las siguientes preguntas con tus propias palabras. La meta es el esfuerzo por recordar, no la perfecci칩n.

**Parte 1: recuperaci칩n de conocimiento (Retrieval Practice)**

1.  Explica c칩mo se representa y manipula un puntero en el lenguaje ensamblador de Hack. Describe las operaciones equivalentes a `p = &a` (asignar direcci칩n) y `*p = 20` (escribir a trav칠s del puntero) usando instrucciones de ensamblador.
2.  쮺칩mo implementar칤as el acceso a un elemento de un arreglo, como `arr[j]`, en lenguaje ensamblador? Describe el rol de la direcci칩n base del arreglo y el 칤ndice `j` en esta operaci칩n.

**Parte 2: reflexi칩n sobre tu proceso (Metacognici칩n)**

1.  쮺u치l fue el concepto m치s abstracto o dif칤cil de "traducir" de C++ a ensamblador en esta unidad (punteros, ciclos, arreglos)? 쯈u칠 hiciste para lograr entenderlo?  
2.  En la Actividad 06 se sugiri칩 construir el programa "PASO A PASO mediante pruebas". 
쮺칩mo te ayud칩 este enfoque a manejar la complejidad del problema?  
3.  Esta unidad fue el "puente" hacia C++. 쯈u칠 concepto de bajo nivel te sientes m치s seguro de poder identificar cuando lo veas implementado en C++?
:::

### Actividad 08

#### Coeveluyaci칩n

**Aprendiendo juntos: coevaluaci칩n constructiva**

En esta actividad vas a revisar la actividad 06 de tu compa침ero. Vas a simular paso 
a paso su programa y dejarle comentarios constructivos. Recuerda que todo lo har치s 
en tu propia bit치cora de aprendizaje y luego compartir치s lo que registraste con tu compa침ero.

:::caution[游닋 Bit치cora]
- Copia la url de la bit치cora revisada.  
- Copia el programa de tu compa침ero.
- Describe detalladamente qu칠 pruebas vas a realizar para saber si el programa funciona correctamente.
- Reporta los resultados de las pruebas.
:::

### Actividad 09    

#### Feedback 

**Mejorando la experiencia: tu feedback es clave**

Tu perspectiva como estudiante es el recurso m치s importante para que yo pueda mejorar este curso. Esta actividad es tu espacio para compartir de forma honesta qu칠 funcion칩, qu칠 no y qu칠 ideas tienes para hacer la experiencia de aprendizaje a칰n mejor.

:::caution[游닋 Bit치cora]

Responde a las siguientes preguntas. La sinceridad y el detalle en tus respuestas son cruciales para que pueda tomar acciones concretas.

1. **Continuar**: 쯈u칠 actividad, problema o explicaci칩n de esta unidad te ayud칩 m치s a entender la conexi칩n entre el bajo y el alto nivel? 쯈u칠 deber칤a mantener sin cambios?
2. **Dejar de hacer**: 쮿ubo alguna actividad o concepto que te pareci칩 redundante, demasiado confuso o que aport칩 poco valor a tu aprendizaje? 쯈u칠 eliminar칤as o modificar칤as?
3. **Empezar a hacer**: 쯈u칠 idea tienes para mejorar la pr칩xima unidad? 쮿ay alg칰n tipo de recurso que 
te habr칤a ayudado a entender mejor los punteros o los arreglos?
4. **Ritmo y Dificultad**: en una escala del 1 (muy f치cil/lento) al 5 (muy dif칤cil/r치pido), 쮺칩mo calificar칤as el salto de dificultad de la Unidad 1 a la Unidad 2? 쮼l ritmo fue adecuado? Justifica tu calificaci칩n.
5. **Comentario Adicional**: 쮸lguna otra cosa que quieras compartir sobre c칩mo te sentiste aprendiendo estos conceptos?
:::

