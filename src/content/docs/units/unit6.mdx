---
title: Unidad 6
unitId: unit6
---

import { Aside } from '@astrojs/starlight/components';

## Introducci√≥n üìú

En la unidad anterior conectamos con los cursos anteriores relacionados con la programaci√≥n orientada a objetos. 
En esta unidad conectaremos con un curso posterior a este: scripting. Lo que haremos es explorar algunos patrones 
de dise√±o que ayudar√°n a estructurar el c√≥digo de manera m√°s eficiente y mantenible, y por tanto, facilitar√° 
el trabajo en equipo.

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

Vas a estudiar en detalle tres patrones de dise√±o: Observer, Factory y State. Estos patrones son soluciones comprobadas 
a problemas comunes en el dise√±o de software orientado a objetos. 

## Seek: Investigaci√≥n üîé

### Actividad 01 

<Aside type="note" title="Enunciado">
En esta actividad inicial, configurar√°s y ejecutar√°s un caso de estudio desarrollado en openFrameworks que utiliza los patrones de dise√±o Observer, 
Factory y State. Tu objetivo es familiarizarte con la aplicaci√≥n, observar su comportamiento e interactuar con ella.
</Aside>

Crea un nuevo proyecto en openFrameworks, adiciona el siguiente c√≥digo, ejec√∫talo y explora la aplicaci√≥n.  

ofApp.h:

```cpp	
#pragma once

#include "ofMain.h"
#include <string>
#include <vector>

class Observer {
public:
	virtual ~Observer() = default;
	virtual void onNotify(const std::string & event) = 0;
};

class Subject {
public:
	void addObserver(Observer * observer);
	void removeObserver(Observer * observer);

protected:
	void notify(const std::string & event);

private:
	std::vector<Observer *> observers; 
};

class Particle;

class State {
public:
	virtual ~State() = default;
	virtual void update(Particle * particle) = 0;
	virtual void onEnter(Particle * particle) { }
	virtual void onExit(Particle * particle) { }
};

class Particle : public Observer {
public:
	Particle();
	~Particle() override;

	Particle(const Particle &) = delete;
	Particle & operator=(const Particle &) = delete;

	void update();
	void draw();
	void onNotify(const std::string & event) override;

	void setState(State * newState);

	ofVec2f position;
	ofVec2f velocity;
	float size;
	ofColor color;

private:
	void keepInsideWindow();
	State * state;
};

class NormalState : public State {
public:
	void update(Particle * particle) override;
	void onEnter(Particle * particle) override;
};

class AttractState : public State {
public:
	void update(Particle * particle) override;
};

class RepelState : public State {
public:
	void update(Particle * particle) override;
};

class StopState : public State {
public:
	void update(Particle * particle) override;
};

class ParticleFactory {
public:
	static Particle * createParticle(const std::string & type); 
};

class ofApp : public ofBaseApp, public Subject {
public:
	~ofApp() override; 
	void setup() override;
	void update() override;
	void draw() override;
	void keyPressed(int key) override;

private:
	std::vector<Particle *> particles;
};


```

ofApp.cpp:

```cpp
#include "ofApp.h"
#include <algorithm>

void Subject::addObserver(Observer * observer) {
	if (!observer) return;
	if (std::find(observers.begin(), observers.end(), observer) == observers.end()) {
		observers.push_back(observer);
	}
}

void Subject::removeObserver(Observer * observer) {
	if (!observer) return;
	observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end());
}

void Subject::notify(const std::string & event) {
	for (Observer * observer : observers) {
		observer->onNotify(event);
	}
}

Particle::Particle()
	: state(nullptr) {
	position = ofVec2f(ofRandomWidth(), ofRandomHeight());
	velocity = ofVec2f(ofRandom(-0.5f, 0.5f), ofRandom(-0.5f, 0.5f));
	size = ofRandom(2.0f, 5.0f);
	color = ofColor(255);

	state = new NormalState();
	state->onEnter(this);
}

Particle::~Particle() {
	if (state) {
		state->onExit(this);
		delete state;
		state = nullptr;
	}
}

void Particle::setState(State * newState) {
	if (state) {
		state->onExit(this);
		delete state; 
	}
	state = newState;
	if (state) {
		state->onEnter(this);
	}
}

void Particle::update() {
	if (state) {
		state->update(this);
	}
	keepInsideWindow();
}

void Particle::draw() {
	ofPushStyle();
	ofSetColor(color);
	ofDrawCircle(position, size);
	ofPopStyle();
}

void Particle::onNotify(const std::string & event) {
	if (event == "attract") {
		setState(new AttractState());
	} else if (event == "repel") {
		setState(new RepelState());
	} else if (event == "stop") {
		setState(new StopState());
	} else if (event == "normal") {
		setState(new NormalState());
	}
}

void Particle::keepInsideWindow() {
	const float W = static_cast<float>(ofGetWidth());
	const float H = static_cast<float>(ofGetHeight());

	if (position.x < 0.0f) {
		position.x = 0.0f;
		velocity.x *= -1.0f;
	} else if (position.x > W) {
		position.x = W;
		velocity.x *= -1.0f;
	}
	if (position.y < 0.0f) {
		position.y = 0.0f;
		velocity.y *= -1.0f;
	} else if (position.y > H) {
		position.y = H;
		velocity.y *= -1.0f;
	}
}

void NormalState::onEnter(Particle * particle) {
	particle->velocity.set(ofRandom(-0.5f, 0.5f), ofRandom(-0.5f, 0.5f));
}

void NormalState::update(Particle * particle) {
	particle->position += particle->velocity;
}

static void steer(Particle * particle, const ofVec2f & toward, float accel, float vmax, float posScale) {
	ofVec2f dir = toward - particle->position;
	float len = dir.length();
	if (len > 1e-6f) {
		dir /= len;
		particle->velocity += dir * accel;
	}
	particle->velocity.limit(vmax);
	particle->position += particle->velocity * posScale;
}

void AttractState::update(Particle * particle) {
	ofVec2f mouse(ofGetMouseX(), ofGetMouseY()); 
	steer(particle, mouse, /*accel*/ 0.05f, /*vmax*/ 3.0f, /*posScale*/ 0.2f);
}

void RepelState::update(Particle * particle) {
	ofVec2f mouse(ofGetMouseX(), ofGetMouseY());
	ofVec2f away = particle->position - mouse;
	float len = away.length();
	if (len > 1e-6f) {
		away /= len;
		particle->velocity += away * 0.05f;
	}
	particle->velocity.limit(3.0f);
	particle->position += particle->velocity * 0.2f;
}

void StopState::update(Particle * particle) {
	particle->velocity *= 0.80f;
	if (particle->velocity.lengthSquared() < 1e-4f) {
		particle->velocity.set(0.0f, 0.0f);
	}
	particle->position += particle->velocity;
}

Particle * ParticleFactory::createParticle(const std::string & type) {
	Particle * particle = new Particle(); 

	if (type == "star") {
		particle->size = ofRandom(2.0f, 4.0f);
		particle->color = ofColor(255, 0, 0);
	} else if (type == "shooting_star") {
		particle->size = ofRandom(3.0f, 6.0f);
		particle->color = ofColor(0, 255, 0);
		particle->velocity *= 3.0f;
	} else if (type == "planet") {
		particle->size = ofRandom(5.0f, 8.0f);
		particle->color = ofColor(0, 0, 255);
	}
	return particle;
}

ofApp::~ofApp() {
	for (Particle * p : particles) {
		removeObserver(p);
		delete p;
	}
	particles.clear();
}

void ofApp::setup() {
	ofBackground(0);
	particles.reserve(100 + 5 + 10);

	for (int i = 0; i < 100; ++i) {
		Particle * p = ParticleFactory::createParticle("star");
		particles.push_back(p);
		addObserver(p);
	}
	for (int i = 0; i < 5; ++i) {
		Particle * p = ParticleFactory::createParticle("shooting_star");
		particles.push_back(p);
		addObserver(p);
	}
	for (int i = 0; i < 10; ++i) {
		Particle * p = ParticleFactory::createParticle("planet");
		particles.push_back(p);
		addObserver(p);
	}
}

void ofApp::update() {
	for (Particle * p : particles) {
		p->update();
	}
}

void ofApp::draw() {
	for (Particle * p : particles) {
		p->draw();
	}
}

void ofApp::keyPressed(int key) {
	switch (key) {
	case 's':
		notify("stop");
		break;
	case 'a':
		notify("attract");
		break;
	case 'r':
		notify("repel");
		break;
	case 'n':
		notify("normal");
		break;
	default:
		break;
	}
}

```

<Aside type="note" title="üßêüß™‚úçÔ∏è Reporta en tu bit√°cora">
1. ¬øC√≥mo puedes interactuar con la aplicaci√≥n? Menciona espec√≠ficamente las teclas y qu√© efecto parecen 
tener sobre las part√≠culas.  
2. ¬øObservas los diferentes tipos de "part√≠culas"? ¬øSe comportan todas igual inicialmente?  
3. Toma algunas capturas de pantalla de la aplicaci√≥n en diferentes momentos (estado inicial, despu√©s de presionar 'a', 'r', 's', 'n') y a√±√°delas a tu bit√°cora.
4. ¬øQu√© crees que est√° pasando "detr√°s de c√°maras" cuando presionas las teclas? Formula una hip√≥tesis inicial sobre c√≥mo la aplicaci√≥n cambia el comportamiento de las part√≠culas.
</Aside>

### Actividad 02

#### Investiga el patr√≥n observer

<Aside type="note" title="Enunciado">

En esta actividad, profundizar√°s en el patr√≥n de dise√±o ``Observer``. Analizar√°s su prop√≥sito, 
estructura y c√≥mo est√° implementado en el caso de estudio que exploraste en la actividad anterior. 
El objetivo es que comprendas c√≥mo este patr√≥n permite la comunicaci√≥n entre objetos de forma desacoplada.
</Aside>


**Concepto del Patr√≥n Observer**

Imagina que quieres recibir notificaciones de una tienda online cuando tu producto favorito vuelve a estar en stock. 
En lugar de revisar la p√°gina web constantemente (polling), te suscribes a las notificaciones. Cuando el producto est√° disponible, 
la tienda (el *Sujeto* u *Observable*) env√≠a autom√°ticamente un mensaje a todos los *Observadores* suscritos (como t√∫).

El patr√≥n Observer define una dependencia uno-a-muchos entre objetos, de manera que cuando un objeto (el Sujeto) cambia su estado, 
todos sus dependientes (Observadores) son notificados y actualizados autom√°ticamente.

Componentes clave:

*   **Subject (Sujeto):** mantiene una ``lista de Observadores``. Proporciona m√©todos para agregar (`attach`/`addObserver`), 
eliminar (`detach`/`removeObserver`) y notificar (`notify`) a los observadores.  
*   **Observer (Observador):** define una interfaz de actualizaci√≥n (`update`/`onNotify`) que ser√° llamada cuando el Sujeto cambie.  
*   **ConcreteSubject (Sujeto Concreto):** almacena el estado de inter√©s y env√≠a notificaciones a sus observadores cuando su estado cambia.  
*   **ConcreteObserver (Observador Concreto):** implementa la interfaz Observer. Almacena una referencia al Sujeto Concreto (opcional) y reacciona a la notificaci√≥n actualizando su propio estado.  

**An√°lisis del caso de estudio**

Vuelve al c√≥digo del caso de estudio (`ofApp.h` y `ofApp.cpp`).

1.  **Identifica los Roles:**
    *   ¬øQu√© clase act√∫a como la interfaz `Observer`? ¬øQu√© m√©todo define?
    *   ¬øQu√© clase act√∫a como `Subject`? ¬øQu√© m√©todos proporciona para gestionar observadores y notificar?
    *   ¬øQu√© clase es el `ConcreteSubject` en esta aplicaci√≥n? ¬øPor qu√©? (Pista: ¬øQui√©n *env√≠a* las notificaciones?)
    *   ¬øQu√© clase(s) act√∫an como `ConcreteObserver`? ¬øPor qu√©? (Pista: ¬øQui√©n *recibe* y *reacciona* a las notificaciones?)

2.  **Sigue el flujo de notificaci√≥n:**
    *   Localiza el m√©todo `keyPressed` en `ofApp.cpp`. ¬øQu√© sucede cuando se presiona la tecla 'a'? ¬øQu√© m√©todo se llama?
    *   Ve al m√©todo `notify` en la clase `Subject`. ¬øQu√© hace este m√©todo?
    *   Localiza el m√©todo que implementa la interfaz `Observer` en la clase `Particle` (`onNotify`). ¬øQu√© hace este m√©todo cuando recibe el evento "attract"?

3.  **Registro y eliminaci√≥n de observadores:**
    *   ¬øEn qu√© parte del c√≥digo se a√±aden las instancias de `Particle` como observadores de `ofApp`? (Busca d√≥nde se llama a `addObserver`).
    *   Aunque no se usa expl√≠citamente en este ejemplo simple, ¬øD√≥nde se eliminar√≠an los observadores si fuera necesario (por ejemplo, si una part√≠cula se destruyera durante la ejecuci√≥n)? (Busca `removeObserver`). ¬øPor qu√© es importante el destructor de `ofApp` en este contexto?

<Aside type="note" title="üßêüß™‚úçÔ∏è Reporta en tu bit√°cora">
1.  Explica con tus propias palabras el prop√≥sito del patr√≥n Observer. ¬øQu√© problema resuelve?
2.  Dibuja un diagrama que muestre la relaci√≥n entre `Subject`, `Observer`, `ofApp` y `Particle` en el caso de estudio, indicando 
qui√©n es el Sujeto y qui√©nes los Observadores.
3.  Construye un diagrama de secuencia que muestre c√≥mo funciona el patr√≥n Observer al presionar una tecla.
4.  ¬øQu√© ventajas crees que ofrece usar el patr√≥n Observer en esta aplicaci√≥n en comparaci√≥n con, por ejemplo, que `ofApp::update` recorriera todas 
las part√≠culas y les dijera directamente que cambien su comportamiento basado en una variable global? Piensa en t√©rminos de acoplamiento y extensibilidad.
</Aside>

### Actividad 03

#### Investiga el Patr√≥n Factory Method

<Aside type="note" title="Enunciado">
Esta actividad se centra en el patr√≥n de dise√±o Factory Method. Investigar√°s su prop√≥sito, c√≥mo abstrae el proceso de creaci√≥n de 
objetos y c√≥mo se utiliza en el caso de estudio para generar diferentes tipos de part√≠culas.
</Aside>

**Concepto del patr√≥n Factory Method**

Imagina que est√°s construyendo un juego que necesita crear diferentes tipos de transporte 
(camiones, barcos, aviones). En lugar de tener c√≥digo de creaci√≥n (`new Camion()`, `new Barco()`) esparcido por toda tu aplicaci√≥n, el 
patr√≥n Factory Method propone definir una interfaz (o un m√©todo en una clase base/existente) para crear objetos, pero deja que sean las 
subclases (o la implementaci√≥n concreta del m√©todo) quienes decidan qu√© clase espec√≠fica instanciar.

El Factory Method es un patr√≥n creacional que proporciona una interfaz para crear objetos en una superclase, mientras permite a las 
subclases alterar el tipo de objetos que se crear√°n. Tambi√©n se puede implementar como un m√©todo est√°tico simple en una clase 
(a veces llamado "Simple Factory" o "Static Factory Method", que es lo que vemos en el caso de estudio).

Prop√≥sito principal:

*   **Desacoplar la creaci√≥n de objetos:** el c√≥digo cliente que necesita un objeto no necesita saber c√≥mo crearlo ni qu√© clase concreta 
se est√° creando. Solo interact√∫a con la interfaz o clase base del producto.
*   **Flexibilidad:** facilita la introducci√≥n de nuevos tipos de productos sin modificar el c√≥digo cliente que utiliza el Factory.

**An√°lisis del caso de estudio**

Revisa nuevamente el c√≥digo, prestando atenci√≥n a la clase `ParticleFactory` y su uso en `ofApp::setup`.

1.  **Identifica la Factory:**
    *   ¬øQu√© clase act√∫a como la factory en este ejemplo?
    *   ¬øCu√°l es el "m√©todo factory" espec√≠fico? ¬øEs un m√©todo de instancia o est√°tico?
    *   ¬øQu√© tipo de objeto devuelve este m√©todo f√°brica?

2.  **Proceso de creaci√≥n:**
    *   Observa el m√©todo `ParticleFactory::createParticle`. ¬øC√≥mo decide qu√© tipo de part√≠cula espec√≠fica crear y configurar?
    *   ¬øQu√© informaci√≥n necesita el m√©todo f√°brica para realizar su trabajo?
    *   ¬øQu√© devuelve si se le pasa un tipo desconocido? ¬øC√≥mo podr√≠as mejorar esto?

3.  **Uso de Factory:**
    *   Localiza `ofApp::setup`. ¬øC√≥mo se utiliza la `ParticleFactory` para poblar el vector `particles`?
    *   Compara esto con la alternativa: ¬øC√≥mo se ver√≠a `ofApp::setup` si *no* usara la f√°brica y tuviera que crear y configurar cada tipo de part√≠cula (`star`, `shooting_star`, `planet`) directamente usando `new Particle()` y luego ajustando sus propiedades (`size`, `color`, `velocity`)?

<Aside type="note" title="üßêüß™‚úçÔ∏è Reporta en tu bit√°cora">
1.  Explica con tus propias palabras el prop√≥sito del patr√≥n Factory Method (o Simple Factory, en este caso). ¬øQu√© problema principal aborda en la creaci√≥n de objetos?
2.  ¬øQu√© ventajas aporta el uso de `ParticleFactory` en `ofApp::setup` en comparaci√≥n con instanciar y configurar las part√≠culas directamente all√≠? Piensa en 
t√©rminos de organizaci√≥n del c√≥digo (SRP - Single Responsibility Principle), legibilidad y facilidad para a√±adir *nuevos* tipos de part√≠culas en el futuro.
3.  Imagina que quieres a√±adir un nuevo tipo de part√≠cula llamada `"black_hole"` que tiene tama√±o grande, color negro y velocidad muy lenta. Describe los pasos que necesitar√≠as 
seguir para implementar esto utilizando la `ParticleFactory` existente. ¬øTendr√≠as que modificar `ofApp::setup`? ¬øPor qu√© s√≠ o por qu√© no?
4.  El m√©todo `createParticle` en el ejemplo es est√°tico. ¬øQu√© implicaciones (ventajas/desventajas) tiene esto comparado con tener una instancia de `ParticleFactory` y 
un m√©todo de instancia `createParticle()`?.
</Aside>

### Actividad 04

#### Investiga el patr√≥n State

<Aside type="note" title="Enunciado">
En esta actividad, explorar√°s el patr√≥n de dise√±o State. Analizar√°s c√≥mo permite a un objeto alterar su comportamiento cuando su estado interno 
cambia, haciendo que el objeto parezca cambiar de clase. Identificar√°s su implementaci√≥n en el caso de estudio y comprender√°s c√≥mo gestiona los 
diferentes comportamientos de las part√≠culas.
</Aside>


**Concepto del patr√≥n State**

Piensa en un reproductor de m√∫sica. Puede estar en estado "Reproduciendo", "Pausado" o "Detenido". Las acciones (como presionar el bot√≥n "Play/Pause") 
tienen diferentes efectos dependiendo del estado actual. Si est√° "Reproduciendo" y presionas, pasa a "Pausado". Si est√° "Pausado" o "Detenido" y presionas, pasa a "Reproduciendo".

El patr√≥n State permite a un objeto encapsular diferentes comportamientos (estados) en objetos separados y delegar la ejecuci√≥n a su objeto de 
estado actual. Esto evita tener grandes bloques `if/else` o `switch` en la clase principal para manejar el comportamiento dependiente del estado.

Componentes clave:

*   **Context (contexto):** mantiene una instancia de una subclase de `State` que define el estado actual. Delega las solicitudes dependientes del estado al 
objeto de estado actual. Puede proporcionar un m√©todo para cambiar su estado. (En nuestro caso, `Particle`).
*   **State (estado):** define una interfaz com√∫n para todos los estados concretos. Esta interfaz declara los m√©todos que representan las operaciones dependientes 
del estado. (En nuestro caso, la clase base `State`).
*   **ConcreteState (estado concreto):** cada subclase implementa un comportamiento asociado con un estado del Contexto. (En nuestro caso, 
`NormalState`, `AttractState`, `RepelState`, `StopState`).

**An√°lisis del caso de estudio**

Examina el c√≥digo (`ofApp.h`, `ofApp.cpp`) enfoc√°ndote en las clases relacionadas con el estado (`State`, `NormalState`, `AttractState`, etc.) y c√≥mo interact√∫an con `Particle`.

1.  **Identifica los componentes:**
    *   ¬øCu√°l es la clase `Context`? ¬øQu√© miembro utiliza para mantener el estado actual?
    *   ¬øCu√°l es la interfaz `State`? ¬øQu√© m√©todos importantes define? (Piensa en `update`, `onEnter`, `onExit`).
    *   Enumera las clases `ConcreteState`. ¬øQu√© comportamiento espec√≠fico encapsula cada una?

2.  **Delegaci√≥n del comportamiento:**
    *   Observa el m√©todo `Particle::update()`. ¬øC√≥mo delega la l√≥gica de actualizaci√≥n al estado actual?
    *   Compara el c√≥digo dentro de `NormalState::update()`, `AttractState::update()`, `RepelState::update()` y `StopState::update()`. ¬øC√≥mo encapsula cada clase un comportamiento diferente?

3.  **Transiciones de estado:**
    *   ¬øC√≥mo cambia una `Particle` de un estado a otro? ¬øQu√© m√©todo es responsable de gestionar la transici√≥n? (Busca `setState`).
    *   ¬øQu√© sucede dentro de `Particle::setState()`? ¬øPor qu√© son importantes los m√©todos `onEnter` y `onExit` de la interfaz `State` (aunque no todos los estados concretos los usen extensivamente en este ejemplo)? ¬øQu√© gestionan `onEnter` y `onExit` en `NormalState`?
    *   ¬øQu√© evento externo (mediado por el patr√≥n Observer, que ya analizaste) desencadena la llamada a `setState` en una `Particle`?

<Aside type="note" title="üßêüß™‚úçÔ∏è Reporta en tu bit√°cora">
1.  Explica con tus propias palabras el prop√≥sito del patr√≥n State. ¬øCu√°ndo es √∫til aplicarlo?
2.  Dibuja un diagrama de estados simple para la clase `Particle`. Muestra los diferentes estados (`Normal`, `Attract`, `Repel`, `Stop`) como nodos y las transiciones 
entre ellos como flechas etiquetadas con el evento que las causa (p. ej., la tecla presionada: 'n', 'a', 'r', 's').
3.  Describe las ventajas de usar el patr√≥n State en `Particle` en lugar de tener un miembro `std::string estadoActual` y usar un gran `if/else if/else` o `switch` dentro 
de `Particle::update()` para cambiar el comportamiento. Piensa en cohesi√≥n, extensibilidad (a√±adir nuevos estados) y el Principio Abierto/Cerrado (Open/Closed Principle).
4.  ¬øQu√© responsabilidad tienen los m√©todos `onEnter` y `onExit` en el patr√≥n State? Proporciona un ejemplo de por qu√© podr√≠an ser √∫tiles (incluso si no se usan mucho en *todos* 
los estados de este caso de estudio). Por ejemplo, ¬øQu√© podr√≠as hacer en `onEnter` para `AttractState` o en `onExit` para `StopState`?
</Aside>

## Apply: Aplicaci√≥n üõ†

### Actividad 05

<Aside type="note" title="Enunciado">
En esta actividad modificar√°s el caso de estudio para a√±adir un nuevo tipo de part√≠cula que utiliza los patrones Observer, Factory y State.
</Aside>


<Aside type="note" title="üßêüß™‚úçÔ∏è Reporta en tu bit√°cora">
1. El c√≥digo fuente completo de tu proyecto openFrameworks.
2. Explica c√≥mo usaste el patr√≥n Factory para esta nueva part√≠cula. 
3. Describe c√≥mo implementaste el patr√≥n Observer para esta nueva part√≠cula.
4. Explica c√≥mo aplicaste el patr√≥n State a esta nueva part√≠cula. 
</Aside>

## Evidencias üóÇÔ∏è

<Aside type="note" title="RUBRICA!">
* Recuerda que la bit√°cora se cierra el 2 de octubre de 2025 a las 7:49 a.m. No olvides que el aprendizaje es un proceso que se 
plasma en la bit√°cora. La bit√°cora no es un resultado que se llena a √∫ltima hora.
* Si no realizas la autoevaluaci√≥n tu nota ser√° 0.
* Si una actividad no est√° COMPLETA debes multiplicar la nota de esa actividad por el porcentaje de avance que tengas.
* Si usas IA para generar c√≥digo, texto o im√°genes la nota en esa actividad ser√° 0.

**R√∫brica de evaluaci√≥n del proceso**

5: realic√© las 5 actividades completas y la autoevaluaci√≥n.  
4: realic√© 4 actividades completas y la autoevaluaci√≥n.  
3: realic√© 3 actividades completas y la autoevaluaci√≥n.  
2: realic√© 2 actividades completas y la autoevaluaci√≥n.  
1: realic√© 1 actividad completa y la autoevaluaci√≥n.  
0: no realic√© ninguna actividad o no realic√© la autoevaluaci√≥n.  
</Aside>

<Aside type="danger" title="EVIDENCIAS EN BIT√ÅCORA">

1. Realiza las actividades propuestas en esta unidad y documenta todo el proceso en tu bit√°cora.  
2. Realiza la autoevaluaci√≥n indicando:
    * Tu nota propuesta.
    * La defensa de esa nota para cada actividad. 
</Aside>



## Reflect: Consolidaci√≥n y metacognici√≥n ü§î

Es momento de hacer una de las fases m√°s importantes del aprendizaje: la reflexi√≥n.

1. En una hoja de papel o un white board digital te pedir√© que hagas un inventario de los 
conceptos de las unidades 1 a la 6. Luego construye un diagrama donde ubiques todos los conceptos, tratando 
de agruparlos y relacionarlos entre s√≠. 
2. Preg√∫ntate: ¬øQu√© conceptos domino bien? ¬øCu√°les me cuestan m√°s trabajo?
3. Preg√∫ntate para qu√© pueden servirte estos conceptos.
4. ¬øQu√© hiciste bien en esta unidad que debes continuar haciendo?
5. ¬øQu√© deber√≠as comenzar a hacer para mejorar tu proceso?
6. Formula tu plan de acci√≥n personal para abordar aquello que te cueste m√°s trabajo.

