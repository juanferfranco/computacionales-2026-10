---
title: Unidad 7
unitId: unit7
---

import { Aside } from '@astrojs/starlight/components';

## Introducci√≥n üìú

En esta unidad vas a realizar una introducci√≥n pr√°ctica a la programaci√≥n gr√°fica moderna. 
Usar√°s, como caso de estudio, un ejemplo b√°sico llamado el tri√°ngulo simple que previamente configur√© 
para ti en Visual Studio con C++, GLFW y GLAD para explorar c√≥mo se crean gr√°ficos acelerados por 
hardware con OpenGL. Nos centraremos en entender el **pipeline programable** analizando ejemplos 
funcionales y culminando con un problema simple que te permita consolidar lo aprendido.

El material de esta unidad es una adaptaci√≥n del curso [learn opengl](https://learnopengl.com/) y 
por limitaciones de tiempo te dar√°s cuanta que, comparado con el curso original, es un poco m√°s 
reducido. La idea es que puedas entender los conceptos b√°sicos de OpenGL.  

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

* **Navegar un proyecto OpenGL b√°sico:** entender√°s la estructura y el ciclo de vida de una aplicaci√≥n gr√°fica simple.  
* **Identificar el rol de los Shaders:** modificar√°s vertex y fragment shaders b√°sicos (GLSL) y entender√°s su impacto.
* **Comprender el flujo de datos:** analizar√°s c√≥mo los datos de v√©rtices (VBOs) se conectan a los shaders 
a trav√©s de la configuraci√≥n de estado (VAOs).
* **Usar Uniforms:** pasar√°s datos din√°micos desde C++ a tus shaders.
* **Aplicar conocimientos:** reforzar√°s tu aprendizaje mediante la soluci√≥n de un problema sencillo.

### Actividad 01 

#### Orientaci√≥n y primer vistazo al entorno gr√°fico

:::note[üéØ Enunciado]
En esta actividad vas a descargar y ejecutar un ejemplo b√°sico introductorio a OpenGL. 
La idea de esta actividad es solo que pongas a funcionar el ejemplo. No es necesario que 
entiendas el c√≥digo en este momento, pero s√≠ que observes de manera general el programa. 
En la fase de investigaci√≥n vas a profundizar en el c√≥digo y en los conceptos de OpenGL.
:::

**Ejemplo simple de un tri√°ngulo en OpenGL:**

1. Abre y explora el programa:

* Descarga el proyecto que est√° en [este repositorio de GitHub](https://github.com/juanferfranco/triangle)
* Descomprime y abre el archivo de soluci√≥n (`.sln`) de Visual Studio proporcionado.
* Observa la estructura del proyecto en el Explorador de Soluciones e identifica el archivo de C++ `.cpp`.

2. Compila y ejecuta el ejemplo

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
1.  Incluye una captura de pantalla del ejemplo funcionando en tu m√°quina.
2.  Observa el proyecto, trata de entenderlo, pero ten presente que lo analizaremos m√°s adelante.
3.  ¬øQu√© preguntas te surgen al ver el c√≥digo?. Anota al menos tres preguntas que te gustar√≠a 
investigar m√°s adelante (no te preocupes que la idea de esta unidad es que las resuelvas).
:::

### Actividad 02

#### ¬øC√≥mo se crea un proyecto OpenGL en Windows?

:::note[üéØ Enunciado]
En esta actividad vas a entender que necesitas para que un programa OpenGL funcione en Windows.
No olvides agregar al proyecto el archivo triangle.cpp de la actividad 
anterior para que puedas ver el ejemplo del tri√°ngulo simple funcionando 
en el proyecto que creaste una vez est√© configurado correctamente.
:::

**¬øC√≥mo se crean un proyecto openGL en Windows?**

En la actividad anterior te entregu√© un ejemplo que vamos a analizar en esta fase de investigaci√≥n. 
El ejemplo ya estaba previamente configurado y listo para compilar y ejecutar. Sin embargo, en esta actividad 
te voy a explicar c√≥mo se crea un proyecto OpenGL desde cero porque hay algunos conceptos fundamentales 
del proceso de creaci√≥n de un proyecto OpenGL que es importante que entiendas. Trata de reproducir el proceso 
en tu m√°quina. Si no lo logras, no te preocupes, en la fase de investigaci√≥n vamos a profundizar en el tema.

Lo primero que necesitas es crear un proyecto vac√≠o (Empty project) en C++ en Visual Studio. 
Luego, necesitas agregar las librer√≠as de OpenGL, GLFW y GLAD. En el ejemplo del tri√°ngulo simple de la actividad 
anterior ya est√°n incluidas las librer√≠as y los archivos de encabezado necesarios. Adem√°s te inclu√≠ una biblioteca 
adicional llamada GLM, que es una biblioteca de matem√°ticas para gr√°ficos 3D. De todas formas, esta biblioteca 
no es estrictamente necesaria para crear un proyecto OpenGL, pero es muy √∫til para trabajar con matrices y vectores.

Volvamos pues a la pregunta inicial: **¬øC√≥mo se crean un proyecto OpenGL en Windows?** Una vez que tienes 
el proyecto vac√≠o creado, lo vas a buscar en el explorador de archivos de Windows. Vas a crear una carpeta 
llamada **external** (observa en el ejemplo del tri√°ngulo simple esta carpeta y su contenido). Dentro de esa carpeta 
guardar√°s las dependencias de tu proyecto. Para hacer esto, crea estas carpetas, que son las que contienen 
las dependencias de tu proyecto:

```bash
glfw34
glad
glm-101-light
```

¬øQu√© dependencias necesitas y por qu√©? Comencemos con **GLFW**. Esta es una biblioteca que te permite crear ventanas 
y manejar eventos de entrada (teclado, rat√≥n, etc.). [GLFW](https://www.glfw.org/) es una biblioteca multiplataforma, lo que 
significa que puedes usarla en Windows, Linux y MacOS. Para conseguir la biblioteca, lo que necesitas es ir al repositorio en 
Github y descargar el archivo glfw-3.4.bin.WIN64.zip que est√° en la secci√≥n de releases. Descomprime el archivo y guarda 
las siguientes carpetas en glfw34:

```bash
include
lib-vc2022
LICENSE.md
README.md
```

La carpeta include contiene los archivos de encabezado de la biblioteca. La carpeta lib-vc2022 contiene las bibliotecas compiladas para Visual Studio 2022.

Ahora sigamos con **GLAD**. Esta es una biblioteca que te permite cargar las funciones de OpenGL. [GLAD](https://glad.dav1d.de/) es un cargador de funciones de 
OpenGL que te permite acceder a las funciones de OpenGL en tiempo de ejecuci√≥n. Para conseguir la biblioteca, lo que haces es ir al sitio web de GLAD y generar 
el c√≥digo fuente para OpenGL 4.6 y el perfil Core. Luego descarga el archivo zip y guarda los directorios src e include en la carpeta glad que hab√≠amos creado antes en external.

Te voy a mostrar unas capturas de pantalla para que veas c√≥mo configurar las opciones en el sitio de GLAD:

![Captura de pantalla de la configuraci√≥n de GLAD](../../../assets/glad1.png)
![Captura de pantalla de la configuraci√≥n de GLAD](../../../assets/glad2.png)

Aqu√≠ tengo varias cosas interesantes para contarte. La primera es la versi√≥n de API de OpenGL. Nota que eleg√≠ la versi√≥n 4.6. 
Esto es porque es la versi√≥n m√°s reciente de OpenGL y es la que vamos a usar en esta unidad. La segunda cosa interesante es el perfil. Eleg√≠ el perfil **Core** porque es el perfil m√°s moderno de OpenGL. El perfil Compatibility es el perfil m√°s antiguo de OpenGL y no lo vamos a usar en esta unidad.

Nos falta otra dependencia, ¬øVerdad? Se trata de GLM. En este caso descargu√© el archivo glm-1.0.1-light.zip del repositorio de [GLM en Github](https://github.com/g-truc/glm/releases/tag/1.0.1). Nota que la versi√≥n descargada es la 1.0.1. Por eso en la carpeta 
externals se crea la carpeta glm-101-light. All√≠ guardas completa la carpeta glm que resulta de descomprimir el archivo zip.

Paremos aqu√≠ un momento. Yo se que est√°s pensando que esto es muy complicado, aburrido y que no tiene nada que ver con OpenGL, pero 
es importante que entiendas c√≥mo funciona el proceso de creaci√≥n de un proyecto OpenGL. Porque este mismo proceso lo podr√°s 
usar para crear otro tipo de proyectos con otras bibliotecas. Por ejemplo, si quieres crear un proyecto con [SDL](https://www.libsdl.org/) o [SFML](https://www.sfml-dev.org/), el proceso es el mismo.

¬øEntonces ya terminamos? La verdad no. Hasta ahora solo hemos descargado las dependencias y las hemos organizado. Ahora 
falta configurar el proyecto en Visual Studio. Para hacer esto, lo que tienes que hacer es abrir el proyecto en Visual Studio y
agregar las rutas de las dependencias a las propiedades del proyecto. Para no aburrirte, te voy a mostrar las capturas de pantalla de c√≥mo lo hice.

Para poder usar las bibliotecas, le digo a Visual Studio d√≥nde est√°n los archivos de cabecera:

![Captura de pantalla de la configuraci√≥n de las propiedades del proyecto](../../../assets/includes.png)

Luego le indico a Visual Studio d√≥nde est√°n las bibliotecas .lib. En este caso solo hay una, que es la de GLFW. Las dem√°s 
dependencias no tienen bibliotecas .lib porque son archivos de c√≥digo fuente.

![Captura de pantalla de la configuraci√≥n de las propiedades del proyecto](../../../assets/libs.png)

Ahora le digo a Visual Studio qu√© .lib espec√≠ficas quiero usar. En este caso solo la de GLFW y una m√°s (ya te digo cu√°l es).

![Captura de pantalla de la configuraci√≥n de las propiedades del proyecto](../../../assets/dependencies.png)

Es posible que hayas notado una librer√≠a adicional llamada opengl32.lib. Esta biblioteca viene incluida con Windows y cumple un papel 
importante: permite crear el contexto inicial de OpenGL y acceder a las funciones b√°sicas de la versi√≥n 1.1. Sin embargo, en nuestros 
ejemplos usaremos funciones m√°s avanzadas (por ejemplo, de OpenGL 3.3 o 4.6), que no est√°n en opengl32.lib, sino en los drivers de la 
tarjeta gr√°fica que tengas instalada. Esos drivers implementan las versiones modernas de OpenGL.

Como esas funciones no se pueden usar directamente, necesitamos una herramienta como GLAD, que se encarga de cargarlas din√°micamente en 
tiempo de ejecuci√≥n. GLAD consulta al sistema operativo y a los drivers para obtener las direcciones de memoria de esas funciones, y 
as√≠ podemos usarlas como si fueran funciones normales en nuestro c√≥digo.

¬øYa terminamos? A√∫n no, pero no te desanimes. Nos falta un paso importante: agregar el archivo de c√≥digo fuente de GLAD al proyecto.

Esto se hace muy f√°cilmente: solo debes a√±adir (ojo, click derecho al proyecto en Visual Studio y seleccionas Add/New item) el archivo 
glad.c que se encuentra en la carpeta glad/src a tu proyecto. Este archivo contiene la implementaci√≥n que permite cargar las funciones 
modernas de OpenGL en tiempo de ejecuci√≥n.

¬øY ahora s√≠? ¬°Ya casi! Solo falta un detalle final: debes asegurarte de que el archivo glfw3.dll est√© en el directorio principal del 
proyecto. Este archivo lo puedes encontrar en la carpeta lib-vc2022 dentro del directorio glfw34 que descargaste previamente.

¬øPor qu√© es necesario este archivo .dll? Porque glfw3.dll es una biblioteca din√°mica que contiene el c√≥digo que implementa las 
funciones de GLFW. Cuando ejecutas tu programa, el sistema necesita encontrar este archivo para poder acceder a esas funciones. Si 
el archivo no est√° presente, el programa compilar√° sin errores (porque usaste la versi√≥n .lib al enlazar), pero fallar√° al ejecutarse. 

¬øY entonces para qu√© sirve el archivo .lib? La biblioteca .lib es utilizada durante la compilaci√≥n y el enlace. Le dice al compilador 
y al enlazador que existen ciertas funciones (como glfwInit() o glfwCreateWindow()), y que esas funciones estar√°n disponibles en 
tiempo de ejecuci√≥n. Pero el c√≥digo real est√° en el .dll, que se necesita cuando el programa se ejecuta.

En resumen:

.lib ‚Üí usado en tiempo de compilaci√≥n para enlazar el programa.

.dll ‚Üí usado en tiempo de ejecuci√≥n para que el programa funcione.

Por eso es crucial que copies glfw3.dll. Con eso, ahora s√≠... ¬°Tenemos todo listo!

**¬øQu√© necesitas para que un programa OpenGL funcione en Windows?**

Al desarrollar con OpenGL en Windows, intervienen varias bibliotecas y archivos que cumplen roles distintos. Aqu√≠ te explico **qu√© hace cada uno y por qu√© es necesario**:

---

`opengl32.lib` (de Windows)

- Es una **biblioteca de enlace est√°tico** incluida con Windows.
- Permite crear el **contexto inicial de OpenGL** y usar funciones b√°sicas de **OpenGL 1.1**.
- Es necesaria para iniciar cualquier programa OpenGL en Windows, aunque no contenga las funciones modernas.

:::note
**D√≥nde est√°n las funciones:** solo hasta OpenGL 1.1.  
**Cu√°ndo se usa:** durante la **compilaci√≥n** para enlazar el inicio de OpenGL.
:::

---

GLFW

- Biblioteca multiplataforma para **crear ventanas**, manejar el **teclado**, el **mouse** y gestionar el contexto OpenGL.
- Requiere dos archivos:
  - `glfw3.lib`: le dice al compilador d√≥nde est√°n las funciones de GLFW.
  - `glfw3.dll`: contiene el **c√≥digo real** que se usa en tiempo de ejecuci√≥n.

:::note
**D√≥nde est√°n las funciones:** en el archivo `glfw3.dll`  
**Cu√°ndo se usa:**  
- `.lib`: en **compilaci√≥n y enlace**.  
- `.dll`: en **ejecuci√≥n**.  
Si no colocas `glfw3.dll` en el directorio de tu ejecutable, el programa compila pero **no corre**.
:::

---

GLAD

- Es un **cargador de funciones de OpenGL**.
- Las funciones modernas de OpenGL (3.3, 4.6) **no est√°n en `opengl32.lib`**: est√°n implementadas por los **drivers de la GPU**.
- GLAD obtiene esas funciones desde el driver usando `wglGetProcAddress` y las hace disponibles en tu c√≥digo.

:::note
**D√≥nde est√°n las funciones:** en los **drivers** de tu tarjeta gr√°fica.  
**Cu√°ndo se usa:** en **tiempo de ejecuci√≥n**, cuando se llama a `gladLoadGL()`.  
Necesitas agregar al proyecto el archivo `glad.c` y sus encabezados (`include/glad/glad.h`).
:::

---

GLM (opcional)

- Biblioteca de matem√°ticas para gr√°ficos: vectores, matrices, transformaciones.
- Es solo c√≥digo fuente (`.hpp`), no requiere `.lib` ni `.dll`.

:::note
**D√≥nde est√°n las funciones:** en los archivos `.hpp` de GLM.  
**Cu√°ndo se usa:** solo en **tiempo de compilaci√≥n**  
No es obligatoria para usar OpenGL, pero es muy √∫til.
:::

---

Conexi√≥n entre todos

1. **GLFW** crea la ventana y el contexto.
2. **opengl32.lib** permite iniciar OpenGL.
3. **GLAD** carga las funciones modernas del driver de tu GPU.
4. **GLM** te ayuda a hacer matem√°ticas para animaciones o transformaciones.

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Necesito que hagas digesti√≥n de esta informaci√≥n y que la entiendas. Para ello te voy a pedir 
un resumen en tus propias palabras de lo que acabas de leer. En tu resumen debes tratar de 
conectar GLFW, opengl32.lib, GLAD, GLM y los drivers de la GPU. ¬øQu√© rol cumple cada uno? ¬øC√≥mo se relacionan entre s√≠? 
Mira, trata de hacer esto de memoria y como si estuvieras cont√°ndole a un amigo que quiere aprender OpenGL. Cuando 
haces el proceso de memoria tu cerebro hace un esfuerzo adicional y eso te ayuda a aprender. Adem√°s, si no recuerdas 
algo quiere decir que no lo entendiste bien y eso es una buena se√±al para que vuelvas a leerlo.
:::


## Seek: Investigaci√≥n üîé

En esta fase vas a explorar los conceptos fundamentales de OpenGL y su pipeline programable. 
Vas a investigar c√≥mo funcionan los shaders y c√≥mo se comunican con el c√≥digo C++. 
Vas a realizar una serie de actividades que te ayudar√°n a entender c√≥mo funcionan los gr√°ficos 
acelerados por hardware y c√≥mo puedes manipularlos.

### Actividad 03

#### An√°lisis del ejemplo del tri√°ngulo simple parte 1

:::note[üéØ Enunciado]
En esta actividad, nos centraremos en el ejemplo m√°s simple, el del tri√°ngulo. Tu estar√°s pensando que estoy loco 
cuando te digo que es el ejemplo simple, pero es as√≠. Este es el hola mundo de OpenGL.
Vas a analizar el c√≥digo del tri√°ngulo simple y vas a entender c√≥mo funciona.
Vas a observar c√≥mo se crea la ventana, c√≥mo funciona el ciclo principal (game loop) y c√≥mo se realiza el dibujo m√°s b√°sico.
No te distraigas, en la fase de aplicaci√≥n te pedir√© que hagas algunas modificaciones, pero no ahora. Nuestro objetivo 
es entender c√≥mo funciona el c√≥digo y c√≥mo se estructura, luego har√°s las modificaciones.
:::

**¬øQu√© es el contexto OpenGL?**

Cuando queremos dibujar gr√°ficos con OpenGL, no basta con escribir llamadas a funciones de OpenGL. Esas funciones necesitan 
un entorno de ejecuci√≥n que gestione todo lo relacionado con OpenGL en tu computador. Ese entorno se llama **contexto OpenGL**.

Un contexto OpenGL es una estructura de datos interna que contiene:

- El estado actual de OpenGL (colores, shaders, buffers, matrices, etc.).
- Los recursos que vas a usar (texturas, VBOs, VAOs, etc.).
- La conexi√≥n con la ventana donde se dibujar√°n los gr√°ficos.
- La versi√≥n de OpenGL que est√°s usando (por ejemplo, 4.6 Core).

Es como si cada contexto fuera un **espacio de trabajo** de OpenGL.

¬øPor qu√© es necesario? OpenGL no funciona por s√≠ solo: necesita saber d√≥nde dibujar y qu√© recursos est√°n disponibles.
Esto se logra asociando un contexto OpenGL a una **ventana**, y asegur√°ndote de que ese contexto est√© activo en el hilo que va a dibujar 
(esto del hilo es un tema que no hemos visto, pero no te preocupes, no es necesario para esta unidad. Lo entender√°s en la unidad que sigue. 
Por ahora piensa que **un hilo es el flujo de las instrucciones de tu programa**). En otras palabras, el contexto OpenGL es el intermediario entre tu c√≥digo y la GPU.

¬øQui√©n crea el contexto? OpenGL no crea contextos por s√≠ solo. T√∫ necesitas una biblioteca que lo haga por ti.
En este caso vamos a usar **GLFW**. GLFW es una biblioteca que te permite crear ventanas y contextos OpenGL de manera sencilla. 
Cada sistema operativo tiene su propia forma de crear ventanas y contextos, y GLFW se encarga de abstraer esas diferencias para que t√∫ no 
tengas que preocuparte por ellas. Con GLFW, puedes crear una ventana y un contexto OpenGL de manera portable y sencilla, sin importar si est√°s en Windows, Linux o MacOS.

Te propongo una analog√≠a para entenderlo mejor: imagina que OpenGL es un artista que necesita un estudio (el contexto) para trabajar. GLFW es 
el arquitecto que construye ese estudio y le da las herramientas necesarias para crear su obra maestra (los gr√°ficos). Sin el estudio, el artista no puede hacer nada.
GLFW se encarga de crear el contexto OpenGL y asociarlo a una ventana. Luego, t√∫ puedes usar OpenGL para dibujar en esa ventana.

Observa la primera parte de la funci√≥n `main` del ejemplo del tri√°ngulo simple:

```cpp
if (!glfwInit()) { ... }
```

Esta l√≠nea inicializa GLFW, la biblioteca que usaremos para crear la ventana y manejar eventos (como teclado, mouse o cambios de tama√±o). 
Si la inicializaci√≥n falla, se imprime un mensaje de error y el programa se termina.  

Importante: GLFW debe inicializarse antes de usar cualquiera de sus funciones.

```cpp
glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
```

Estas l√≠neas configuran el contexto OpenGL que queremos crear:

- Especificamos la versi√≥n 4.6 de OpenGL.
- Usamos el perfil Core, que excluye funciones obsoletas (como glBegin, glEnd).

¬øRecuerdas qu√© es el contexto de OpenGL? **Cierra los ojos e intenta recuperar de memoria** la analog√≠a del artista y el estudio.

Contexto OpenGL: es el entorno donde OpenGL guarda todo el estado gr√°fico (shaders, texturas, buffers, etc.).
Lo necesitas para que las funciones de OpenGL tengan efecto.

```cpp
GLFWwindow* mainWindow = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "Ventana", NULL, NULL);
``` 

Esta l√≠nea crea una ventana de 800x600 p√≠xeles y le asocia un contexto OpenGL. Si la creaci√≥n falla, se imprime un error y el programa 
se termina. Este contexto ser√° el que usaremos para dibujar con OpenGL.

```cpp
int bufferWidth, bufferHeight;
glfwGetFramebufferSize(mainWindow, &bufferWidth, &bufferHeight);
```

Esta l√≠nea obtiene el tama√±o del framebuffer de la ventana. **¬øQu√© es el framebuffer?** El framebuffer 
es una porci√≥n de memoria donde OpenGL dibuja los p√≠xeles antes de enviarlos a la pantalla.
Podemos imaginarlo como una ‚Äúhoja invisible‚Äù donde OpenGL pinta cada imagen cuadro a cuadro.

Este tama√±o puede ser diferente al tama√±o de la ventana en p√≠xeles, especialmente en pantallas 
con escalado (como pantallas retina). ¬øPor qu√©? En pantallas Hi‚ÄëDPI (Retina) cada ‚Äúp√≠xel l√≥gico‚Äù de la ventana se representa con varios 
p√≠xeles f√≠sicos; por ello el framebuffer, que usa los p√≠xeles f√≠sicos reales, puede tener dimensiones mayores que las reportadas para la ventana.

Aqu√≠ te estar√°s preguntando, cuando se dice que OpenGL dibuja en el framebuffer, ¬øQu√© significa eso? 
¬øNo se supone que quien dibuja es la GPU? Entonces **¬øQui√©n dibuja: la GPU o OpenGL?** La respuesta corta es:

> La GPU es quien realmente dibuja, y OpenGL es la API que le dice a la GPU qu√© y c√≥mo dibujar.

Entonces repasemos un poco: 

**¬øQu√© es OpenGL?** OpenGL es una interfaz (API): un conjunto de funciones que t√∫ como programador usas para 
enviar instrucciones a la GPU. OpenGL no dibuja directamente. En cambio, traduce tus comandos en operaciones que la GPU ejecuta.

**¬øY qu√© hace la GPU?** 

- Toma los datos de entrada que le pasas (v√©rtices, texturas, shaders‚Ä¶). 
- Ejecuta los shaders: peque√±os programas que definen c√≥mo transformar esos datos en p√≠xeles.
- Dibuja en el framebuffer, que es memoria de video (RAM de la GPU).

En otras palabras:

- T√∫ escribes c√≥digo OpenGL en C++.
- OpenGL lo convierte en instrucciones que la GPU entiende.
- La GPU hace el trabajo pesado en paralelo, pintando los p√≠xeles en el framebuffer.

**¬øPor qu√© se dice entonces que ‚ÄúOpenGL dibuja‚Äù?** Porque es una simplificaci√≥n √∫til cuando 
est√°s empezando. OpenGL es el lenguaje de control, pero el artista es la GPU. Decir "OpenGL dibuja 
en el framebuffer" es como decir que Photoshop hace el dise√±o: en realidad, lo haces t√∫ usando 
la herramienta.

Como analog√≠a final considera lo siguiente:

- T√∫ (el programador) -> Dise√±as la escena, es decir, lo qu√© se va a dibujar y c√≥mo.
- OpenGL -> El lenguaje que usas para dar instrucciones.
- GPU -> El artista que ejecuta todo el trabajo gr√°fico.
- Framebuffer -> La hoja donde el artista (GPU) pinta.
- Pantalla / La galer√≠a donde muestras el resultado final.

```cpp
glfwMakeContextCurrent(mainWindow);
```
Aqu√≠ hacemos que el contexto OpenGL asociado a mainWindow sea el contexto actual.
Esto es fundamental: cualquier funci√≥n de OpenGL que llamemos a partir de ahora afectar√° a este contexto.

```cpp
glfwSetFramebufferSizeCallback(mainWindow, framebuffer_size_callback);
```

Esta l√≠nea registra una funci√≥n de callback que se ejecutar√° cada vez que la ventana cambie de tama√±o.

En este caso, la funci√≥n framebuffer_size_callback har√° lo siguiente:

```cpp	
glViewport(0, 0, width, height);
```

**¬øQu√© es el viewport?** El viewport define qu√© parte del framebuffer se usar√° para dibujar.
Se mide en p√≠xeles y normalmente coincide con el tama√±o completo del framebuffer.

Si el viewport no se ajusta correctamente al tama√±o del framebuffer, lo que dibujas podr√≠a 
aparecer estirado, recortado o mal posicionado.

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Qu√© tal si ensayas. Prueba con esta l√≠nea 
```cpp
// 9) Configura el viewport
glViewport(0, 0, bufferWidth, bufferHeight);
```
¬øQu√© pasa si?

```cpp	
glViewport(0, bufferHeight/2, bufferWidth/2, bufferHeight/2);
```
Cambia los valores de bufferWidth y bufferHeight: divide por 2, por 4, multiplica por 2, por 4, etc.
¬øQu√© pasa? ¬øQu√© observas? ¬øQu√© crees que est√° pasando?
:::


<Aside type="tip" title="Resumen hasta aqu√≠">

| Concepto        | ¬øQu√© es?                                               | ¬øPor qu√© es importante?                                            |
|-----------------|--------------------------------------------------------|--------------------------------------------------------------------|
| **GLFW**        | Biblioteca para crear la ventana y manejar eventos.    | Nos evita programar c√≥digo espec√≠fico de cada sistema operativo.   |
| **Contexto OpenGL** | Entorno donde OpenGL guarda todo su estado.        | Sin √©l, no se pueden ejecutar funciones de OpenGL.                 |
| **Framebuffer** | Memoria donde OpenGL dibuja cada cuadro.               | Es lo que finalmente se muestra en pantalla.                       |
| **Viewport**    | √Årea del framebuffer donde se dibuja.                  | Define el espacio visible. Debe ajustarse al tama√±o del framebuffer. |

</Aside>


:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Ya llevas un rato leyendo y no has hecho **digesti√≥n**. Para favorecer tu aprendizaje, es necesario que 
te detengas un momento y **ELABORES** lo que has visto hasta ahora. Mira, quiero contarte algo. 
Lo que he venido haciendo de manera impl√≠cita en el curso es ense√±arte a **aprender a aprender**. 
¬øTe has dado cuenta? Te voy exponiendo a conceptos y luego te pido que experimentes, que los pongas en pr√°ctica, que los 
reflexiones. Entonces, no te quedes largos periodos de tiempo leyendo, viendo tutoriales o escuchando. Cada cierta cantidad 
de tiempo, puede ser cada 30 minutos o cada hora, haz una pausa y reflexiona sobre lo que has aprendido.

¬øC√≥mo lo haces? Realiza un resumen de lo que has aprendido hasta ahora, haciendo un diagrama conceptual o un mapa mental. 
Experimentando. ¬øC√≥mo? Haciendo la pregunta m√°gica: ¬øQu√© pasar√≠a si? ¬øQu√© pasar√≠a si cambio el tama√±o de la ventana? ¬øQu√© pasar√≠a si cambio el tama√±o del viewport?

Entonces hagamos "digesti√≥n": en tu bit√°cora, escribe un resumen de lo que has aprendido hasta ahora y piensa en un experimento del tipo ¬øQu√© pasar√≠a si?
:::

```cpp
gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)
```

Esta l√≠nea carga las funciones de OpenGL en el contexto actual. GLAD es una biblioteca que se encarga de cargar las funciones de OpenGL y hacerlas 
accesibles en tu programa. Sin esta l√≠nea, no podr√≠as usar las funciones de OpenGL.

```cpp
glfwSwapInterval(1);
```
Esta l√≠nea activa la sincronizaci√≥n vertical (VSync), que limita la tasa de refresco de la ventana al mismo valor que la tasa de refresco del monitor. 
Esto evita el **tearing** y hace que el movimiento sea m√°s suave.

```cpp
shaderProg = buildShaderProgram();
```

Esta l√≠nea llama a la funci√≥n buildShaderProgram(), que compila y enlaza los shaders (vertex y fragment) que usaremos para dibujar el tri√°ngulo.
Esta funci√≥n es fundamental porque los shaders son los programas que OpenGL ejecuta en la GPU para procesar los v√©rtices y fragmentos (p√≠xeles) 
de la escena. Sin shaders, OpenGL no sabe c√≥mo dibujar nada.

```cpp	
setupTriangle();
```
Esta l√≠nea llama a la funci√≥n setupTriangle(), que configura los datos del tri√°ngulo (posici√≥n de los v√©rtices) y los carga en la GPU. Esta 
funci√≥n es fundamental porque define c√≥mo se ver√° el tri√°ngulo en pantalla.
Esta funci√≥n es la que se encarga de crear el VBO y el VAO del tri√°ngulo (m√°s sobre los shaders, VBOs y VAOs en un rato).

```cpp	
glViewport(0, 0, bufferWidth, bufferHeight);
```

Esta l√≠nea define el viewport, que es el √°rea del framebuffer donde OpenGL dibujar√°. En este caso, se ajusta al tama√±o del framebuffer de la ventana. 
Ya lo hab√≠amos discutido antes, pero es importante que lo repases. Te dejo esta simulaci√≥n 
para que entiendas mejor c√≥mo funciona el viewport: [viewport simulation](https://editor.p5js.org/juanferfranco/sketches/-BE4VgV1h).

```cpp	
while (!glfwWindowShouldClose(mainWindow))
{
    // 11) Manejo de eventos
    glfwPollEvents();


    // 12) Procesa la entrada
    processInput(mainWindow);

    // 13) Configura el color de fondo y limpia el framebuffer
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    
    // 14) Indica a OpenGL que use el shader program
    glUseProgram(shaderProg);

    // 15) Activa el VAO y dibuja el tri√°ngulo
    glBindVertexArray(VAO);
    glDrawArrays(GL_TRIANGLES, 0, 3);

    // 16) Intercambia buffers y muestra el contenido
    glfwSwapBuffers(mainWindow);
}
```

Esta es la parte m√°s importante del ciclo principal (game loop) de OpenGL. Aqu√≠ es donde ocurre la magia.
Vamos a desglosar cada l√≠nea:

```cpp
while (!glfwWindowShouldClose(mainWindow))
```

Este es el bucle principal del programa. Se ejecuta mientras la ventana no est√© cerrada.
Dentro de este bucle, se procesan los eventos, se actualiza la l√≥gica del programa y se dibuja la escena. 
La funci√≥n glfwWindowShouldClose(mainWindow) devuelve true si el usuario ha cerrado la ventana (por ejemplo, haciendo clic en la X).

```cpp
glfwPollEvents();
```

Esta funci√≥n procesa todos los eventos pendientes de la ventana. Esto incluye eventos de teclado, mouse y cambios de tama√±o.
Es importante llamar a esta funci√≥n en cada iteraci√≥n del bucle principal para que la ventana responda a las entradas del usuario.

```cpp
processInput(mainWindow);
```

Esta funci√≥n procesa la entrada del teclado. En este caso, se encarga de cerrar la ventana si el usuario presiona la tecla ESC.

```cpp
glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
```

Esta l√≠nea establece el color de fondo de la ventana. El primer par√°metro es el rojo, el segundo el verde, el tercero el azul y el cuarto 
la opacidad (alpha). En este caso, se establece un color azul claro.

```cpp
glClear(GL_COLOR_BUFFER_BIT);
```

Esta l√≠nea limpia el framebuffer, es decir, borra el contenido anterior y lo prepara para dibujar la nueva escena.

```cpp
glUseProgram(shaderProg);
```
Esta l√≠nea indica a OpenGL que use el shader program que hemos creado anteriormente (shaderProg).
Esto es fundamental porque los shaders son los que definen c√≥mo se procesan los v√©rtices y fragmentos (p√≠xeles) de la escena. Sin 
esta l√≠nea, OpenGL no sabr√≠a qu√© shader usar para dibujar.

```cpp
glBindVertexArray(VAO);
```

Esta l√≠nea activa el Vertex Array Object (VAO) que hemos creado anteriormente. El VAO es un objeto que encapsula todos los estados de 
los buffers y atributos de v√©rtices necesarios para dibujar el tri√°ngulo. Al activar el VAO, le decimos a OpenGL que use los datos de v√©rtices que hemos configurado previamente.

```cpp
glDrawArrays(GL_TRIANGLES, 0, 3);
```
Esta l√≠nea le dice a OpenGL que dibuje el tri√°ngulo. GL_TRIANGLES indica que queremos dibujar un tri√°ngulo, 0 es el √≠ndice de inicio 
y 3 es el n√∫mero de v√©rtices a dibujar (un tri√°ngulo necesita tres v√©rtices o puntos).

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
¬øQu√© pasa si cambias el primer par√°metro de glDrawArrays a GL_LINES? ¬øQu√© pasa si lo cambias a GL_POINTS? ¬øQu√© pasa si cambias el 
tercer par√°metro a 2? ¬øQu√© pasa si lo cambias a 4?

En esta unidad no profundizaremos en los tipos de primitivas, pero es importante que entiendas que OpenGL puede dibujar diferentes tipos de primitivas (tri√°ngulos, l√≠neas, puntos, etc.).
:::


```cpp
glfwSwapBuffers(mainWindow);
```

Esta l√≠nea muestra en pantalla el contenido del framebuffer que OpenGL acaba de renderizar.
Internamente, intercambia (por eso la palabra **Swap**) el buffer trasero (donde dibujas) con el buffer delantero (que se ve en pantalla), 
una t√©cnica llamada **doble buffering** que evita parpadeos y asegura una imagen fluida.

```cpp	
// 17) Limpieza
glfwMakeContextCurrent(mainWindow);
glDeleteVertexArrays(1, &VAO);
glDeleteBuffers(1, &VBO);
glDeleteProgram(shaderProg);

glfwDestroyWindow(mainWindow);
glfwTerminate();
```

Esta parte del c√≥digo se encarga de limpiar los recursos utilizados por OpenGL y GLFW antes de cerrar el programa. Es importante liberar 
la memoria y los recursos que ya no se necesitan para evitar fugas de memoria y otros problemas. Claro que en este caso 
el programa se termina inmediatamente, pero es una buena pr√°ctica hacerlo.


:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Vamos a terminar esta actividad con un nuevo momento de consolidaci√≥n parcial. Hay algunos conceptos 
relacionados con los shaders y el pipeline de OpenGL que no hemos visto en detalle, pero no te preocupes, 
los vamos a trabajar en la siguiente actividad. Por ahora, quiero que te concentres en lo que has aprendido hasta aqu√≠.
Explica con tus propias palabras los siguientes conceptos. Puedes usar ejemplos, analog√≠as o diagramas para 
ilustrar tus respuestas. Es importante que intentes responder estos conceptos sin ver inicialmente tus notas. Trata 
de ejercitar tu memoria y tu comprensi√≥n. Luego, puedes revisar tus notas para completar o corregir lo que hayas escrito.

1.  ¬øQu√© es el contexto OpenGL?
2. ¬øCu√°l es el rol de la biblioteca GLFW y qu√© ventaja tiene usarla?
3. ¬øPor qu√© crees que OpenGL necesita un contexto (recuerda la analog√≠a del taller de arte)?
4. ¬øEn √∫ltimas qu√© ser√° el framebuffer y a qu√© te recuerda de las dos primeras unidades del curso?
5. ¬øQu√© relaci√≥n entre en el viewport y el framebuffer?
6. ¬øEn todo la analizado hasta ahora qu√© rol juega los drivers de la GPU y la GPU misma?
7. ¬øPor qu√© crees que sea necesario activar el VSync? ¬øSi no lo activas y la imagen es est√°tica qu√© crees que pase, y si es din√°mica?
8. En esta unidad estamos usando OpenGL moderno, pero ¬øQu√© es OpenGL Legacy? ¬øQu√© diferencias hay entre ambos?
9. ¬øQu√© es el shader program? ¬øPor qu√© es importante en OpenGL moderno?
10. Trata de revisar el c√≥digo setupTriangle(), intuitivamente ¬øQu√© crees que hace? ¬øQu√© crees que es el VAO y el VBO?
11. En el ciclo principal (game loop) de OpenGL, notaste que en cada frame (cuadro) le decimos a openGL que use el shader program y 
el VAO. Si le indicas esto antes del game loop ¬øSer√° necesario seguirlo haciendo en cada loop? Si no es necesario ¬øEn qu√© casos 
crees que esto puede ser √∫til?
12. Finalmente, recuerda lo que hace glfwSwapBuffers(mainWindow); ¬øPor qu√© crees que es importante? ¬øQu√© pasar√≠a si no lo llamas? 
¬øC√≥mo explicas lo que pasa si no lo llamas? (experimenta)
:::


### Actividad 04

#### An√°lisis del ejemplo del tri√°ngulo simple parte 2

:::note[üéØ Enunciado]
En la actividad anterior dejamos de lado algunos conceptos fundamentales de OpenGL. En esta actividad vamos a analizar el c√≥digo del 
ejemplo del tri√°ngulo simple y a entender c√≥mo funciona el pipeline de OpenGL. Vamos a ver c√≥mo se comunican los shaders con el 
c√≥digo C++ y c√≥mo se env√≠an los datos a la GPU.
:::

**¬øCu√°l es la diferencia entre una CPU y una GPU** para responder esta pregunta te pedir√© que veas el siguiente 
video de NVIDIA. No te asustes, es muy entretenido. [Mythbusters Demo GPU versus CPU](https://youtu.be/Ge-g3xZ5bb8?si=9ed9dNlnVljpAOVn).

:::note[üßê‚úçÔ∏è Reporta en tu bit√°cora]
Luego de estudiar las unidades 1 y 2 de este curso y ver el video, escribe con tus propias palabras ¬øCu√°l es la diferencia 
entre una CPU y una GPU? 
:::

**¬øC√≥mo funcionan las gr√°ficas en un computador?** De nuevo te voy a proponer que veas un video hermoso. La animaci√≥n 
es incre√≠ble y la explicaci√≥n es muy clara. [How Graphics Work](https://youtu.be/C8YtdC8mxTU?si=t41oXWfbK2Q3TSzf), eso si, 
reconozco que es mucha informaci√≥n. Si te hace falta, puedes pausar el video y volver a ver partes que no entendiste.

:::note[üßê‚úçÔ∏è Reporta en tu bit√°cora]
Es momento de practicar la t√©cnica de **aprender a aprender** que te he venido mostrando de manera insistente a lo largo 
del curso. Te voy a proponer una serie de preguntas para que reflexiones y escribas en tu bit√°cora. Trata de responder 
de memoria a cada pregunta. No busques la respuesta en el video. Trata de recordar lo que viste. De todas maneras 
si no lo logras hacer, regresa al video y busca la respuesta.

1.  ¬øCu√°les son los tres pasos claves del pipeline de OpenGL? Explica en tus propias palabras cu√°l es el objetivo 
de cada paso.
2. La gran novedad que introduce OpenGL moderno es el pipeline programable. ¬øQu√© significa esto? ¬øQu√©
diferencia hay entre el pipeline fijo y el programable? ¬øQu√© ventajas le ves a esto? y si el pipeline es programable, ¬øQu√© tengo 
que programar?
3. Si fueras a describir el proceso de **rasterizaci√≥n** ¬øQu√© dir√≠as?
4. ¬øQu√© son los fragmentos? ¬øEs lo mismo un fragmento que un pixel? ¬øPor qu√©?
5. Explica qu√© problema resuelve el **Z-buffer** y ¬øQu√© es el depth test?
6. ¬øPor qu√© se presenta el problema de la **aliasing**? ¬øQu√© es el anti-aliasing?
7. ¬øQu√© relaci√≥n hay entre la iluminaci√≥n y el fragment shader? Siempre es necesario tener en cuenta la iluminaci√≥n 
en un fragment shader? o puedo hacer un fragment shader sin iluminaci√≥n? Explica que implicaciones tiene esto.
8. ¬øQu√© implica para la GPU que una aplicaci√≥n tenga m√∫ltiples fuentes de iluminaci√≥n?
:::

Ahora que ya conoces c√≥mo funciona el pipeline de OpenGL, vamos a analizar las partes del c√≥digo del ejemplo del tri√°ngulo simple 
que dejamos pendientes en la actividad anterior. 

```cpp	
// 7) Compila y linkea shaders
shaderProg = buildShaderProgram();

// 8) Genera el contenido a mostrar
setupTriangle();
```

Antes de abordar a fondo estas l√≠neas de c√≥digo, es importante que analicemos el concepto de OBJETOS en OpenGL.
En OpenGL, los objetos son entidades que representan recursos gr√°ficos. Estos recursos pueden incluir texturas, buffers de 
v√©rtices, shaders y otros elementos necesarios para renderizar gr√°ficos en la GPU. Cada objeto tiene un identificador √∫nico 
(ID) que se utiliza para referenciarlo en las llamadas a funciones de OpenGL.
Los objetos en OpenGL son gestionados por la GPU y permiten optimizar el rendimiento al reducir la cantidad de datos que 
deben ser transferidos entre la CPU y la GPU. Al crear un objeto, la asignaci√≥n de un ID √∫nico permite a la GPU acceder 
r√°pidamente a los recursos necesarios para renderizar gr√°ficos, de esa manera no es necesario enviar los datos de los 
objetos cada vez que se quiere renderizar una escena. En su lugar, OpenGL utiliza el ID del objeto para acceder a los datos almacenados en la GPU.

En este punto ya hemos analizado un gran objeto de OpenGL denominado el **contexto de OpenGL**. Este objeto es el que permite a 
OpenGL comunicarse con la GPU y gestionar los recursos gr√°ficos. Dentro de este contexto, OpenGL crea y gestiona otros objetos 
como los buffers de v√©rtices, los shaders y las texturas. Cada uno de estos objetos tiene su propio ID √∫nico que se utiliza para 
referenciarlo en las llamadas a funciones de OpenGL.

La estructura general de creaci√≥n y uso de un objeto OpenGL es la siguiente:

```cpp
// Crea la variable que contendr√° el ID del objeto
unsigned int objectId = 0;
// Genera el objeto y asigna un ID √∫nico
glGenObject(1, &objectId);
// Asocia el objeto a un destino espec√≠fico dentro del contexto de OpenGL.
glBindObject(GL_WINDOW_TARGET, objectId);
// Establece opciones para el objeto
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH,  800);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);
// Hace una desactivaci√≥n del objeto o un UNBINDING
glBindObject(GL_WINDOW_TARGET, 0);
``` 

Si luego se quiere usar el objeto, se hace un **binding** del objeto y todos los comandos que se env√≠an a OpenGL 
se aplican a ese objeto. Por ejemplo, si se quiere usar un shader, se hace un binding del shader y todos los comandos que se 
env√≠an a OpenGL se aplican a ese shader. Esto permite a OpenGL gestionar m√∫ltiples objetos de manera eficiente y optimizar el 
rendimiento al reducir la cantidad de datos que deben ser transferidos entre la CPU y la GPU.

Vamos a repasar algunas de las etapas del pipeline de OpenGL y c√≥mo se relacionan con el c√≥digo que hemos visto hasta ahora. Para 
ello vamos a tomar como referencia esta imagen tomada del curso [learnopengl.com](https://learnopengl.com/Getting-started/Hello-Triangle):

![render pipeline](../../../assets/pipeline.png)

Observa en la gr√°fica que lo primero que se recibe son los datos de los v√©rtices. Estos datos son
enviados a la GPU y se almacenan en un buffer de v√©rtices (VBO). Este buffer es un objeto OpenGL que contiene los datos de los v√©rtices 
y se utiliza para enviar estos datos a la GPU. En el c√≥digo del ejemplo del tri√°ngulo simple, esto se hace en la funci√≥n `setupTriangle()`.

```cpp
void setupTriangle() {
	float vertices[] = {
		-0.5f, -0.5f, 0.0f,
		 0.5f, -0.5f, 0.0f,
		 0.0f,  0.5f, 0.0f
	};

	glGenVertexArrays(1, &VAO);
	glGenBuffers(1, &VBO);

	glBindVertexArray(VAO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);
	glBindVertexArray(0);
}
```

Nota que lo primero que hacemos es definir los v√©rtices del tri√°ngulo. Luego, creamos un **objeto VAO** (Vertex Array Object) y 
un **VBO** (Vertex Buffer Object). El objeto VAO es un objeto OpenGL que contiene la configuraci√≥n de los atributos de los 
v√©rtices y el objeto VBO es un objeto OpenGL que contiene los datos de los v√©rtices. F√≠jate que luego de crear los objetos para 
obtener el ID, hacemos un binding del VAO y del VBO. Esto significa que todos los comandos que se env√≠an a OpenGL se aplican a 
estos objetos. Luego, enviamos los datos de los v√©rtices al buffer de v√©rtices (VBO) y configuramos los atributos de los v√©rtices. 
Finalmente, hacemos un UNBINDING del VAO.

```cpp
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```

Esta l√≠nea de c√≥digo env√≠a los datos de los v√©rtices al buffer de v√©rtices (VBO). El primer par√°metro es el tipo de buffer, 
el segundo es el tama√±o de los datos, el tercero son los datos (un puntero al primer elemento del arreglo) y el cuarto es la 
forma en que se van a usar los datos. En este caso, estamos usando `GL_STATIC_DRAW` porque los datos no van a cambiar. Si los datos de 
los v√©rtices cambian, se puede usar `GL_DYNAMIC_DRAW` por ejemplo.

```cpp
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
```

Esta l√≠nea de c√≥digo configura los atributos de los v√©rtices. El primer par√°metro es el √≠ndice del atributo (en este caso 0), 
el segundo es el n√∫mero de componentes por v√©rtice (en este caso 3, porque cada v√©rtice tiene 3 coordenadas), el tercero es el 
tipo de dato (en este caso `GL_FLOAT`), el cuarto es si los datos est√°n normalizados o no (en este caso `GL_FALSE`), el quinto 
es el tama√±o del paso entre los atributos (en este caso 3 * sizeof(float)) y el sexto es un puntero al primer elemento del arreglo.

Te mostrar√© todo esto con un diagrama para que lo entiendas mejor:

![VBO con un atributo](../../../assets/VBO-1Attr.webp)

Cada uno de los par√°metros de la funci√≥n `glVertexAttribPointer` se puede entender de la siguiente manera:

```cpp
glVertexAttribPointer(
    GLuint index,         // Atributo del shader (layout(location = index))
    GLint size,           // Componentes por v√©rtice (1‚Äì4)
    GLenum type,          // Tipo de dato (GL_FLOAT, GL_INT, etc.)
    GLboolean normalized, // ¬øNormalizar datos enteros?
    GLsizei stride,       // Espaciado (en bytes) entre v√©rtices
    const void* pointer   // Desplazamiento inicial dentro del VBO
);
```

```cpp
glEnableVertexAttribArray(0);
```

Esta l√≠nea de c√≥digo habilita el atributo de v√©rtice. El par√°metro es el √≠ndice del atributo (en este caso 0). 
Te estar√°s preguntado ¬øQu√© es eso de los atributos? **¬øQu√© es eso de los vertex attributes?**
Los atributos de v√©rtice son propiedades que describen cada v√©rtice en un buffer de v√©rtices. Estos atributos pueden 
incluir informaci√≥n como la posici√≥n, el color, las coordenadas de textura y las normales. Cada atributo tiene un √≠ndice √∫nico 
que se utiliza para referenciarlo en el shader. En el ejemplo del tri√°ngulo simple, solo estamos usando la **posici√≥n** del 
v√©rtice como atributo. Sin embargo, en aplicaciones m√°s complejas, puedes tener m√∫ltiples atributos por v√©rtice. Te prometo que voy 
a retomar esto en un momento y lo ampliaremos un poco m√°s.

```cpp
glBindVertexArray(0);
```

Finalmente, hacemos un UNBINDING del VAO. Esto significa que todos los comandos que se env√≠an a OpenGL no se aplican a este 
objeto. Esto es importante porque si no hacemos un UNBINDING, todos los comandos que se env√≠an a OpenGL se aplican a este 
objeto y esto puede causar problemas.

Ahora, observa de nuevo las posiciones de los v√©rtices:

```cpp
float vertices[] = {
	-0.5f, -0.5f, 0.0f,
	 0.5f, -0.5f, 0.0f,
	 0.0f,  0.5f, 0.0f
};
```

No te has preguntado ¬øC√≥mo hago para definir los v√©rtices? ¬øQu√© significa cada n√∫mero? ¬øPor qu√© son esos n√∫meros?
En OpenGL, los v√©rtices se definen en un espacio de **coordenadas de dispositivo normalizadas** (NDC). Esto significa que 
las coordenadas van de -1 a 1. En este caso, el primer v√©rtice est√° en la esquina inferior izquierda (-0.5, -0.5), el 
segundo v√©rtice est√° en la esquina inferior derecha (0.5, -0.5) y el tercer v√©rtice est√° en la parte superior (0, 0.5). Te lo aclaro con 
una figura:

![NDC](../../../assets/triangle-ndc.webp)

Ya con esta informaci√≥n, volvamos ahora a la figura del pipeline de OpenGL. Ya te habl√© entonces de los datos que va 
a recibir la GPU (Vertex Data[] en la figura). Ahora te hablar√© de los shaders. En OpenGL moderno es obligatorio 
usar shaders. Debes crear al menos un shader para poder usar OpenGL. En el ejemplo del tri√°ngulo simple, estamos 
usando un shader de v√©rtices y un shader de fragmentos. Estos shaders son programas que se ejecutan en la GPU y se 
utilizan para procesar los datos de los v√©rtices y los fragmentos. En el c√≥digo del ejemplo del tri√°ngulo simple, 
la **creaci√≥n del objeto que contendr√° los shaders** se hace en la funci√≥n `buildShaderProgram()`. Este objeto tiene 
un ID √∫nico que se utiliza para referenciarlo en las llamadas a funciones de OpenGL. Sin embargo, el shader no se 
ejecuta hasta que se hace un binding de este (lo activo). En el ejemplo del tri√°ngulo simple, esto se hace en la 
funci√≥n `glUseProgram(shaderProg);`. De esta manera al llamar `glDrawArrays(GL_TRIANGLES, 0, 3);` se le dice a OpenGL 
que use el shader que hemos activado (bind) y que dibuje los v√©rtices que hemos definido. 

Ahora, al observar el c√≥digo de la funci√≥n `buildShaderProgram()` ver√°s que primero creamos un shader de v√©rtices, lo compilamos y 
verificamos si hubo errores. Luego hacemos lo mismo con el shader de fragmentos. Finalmente, creamos un **objeto programa** y le 
asociamos los shaders. Luego, enlazamos (linkeamos) el programa y verificamos si hubo errores. Si todo sale bien, eliminamos 
los shaders porque ya no los necesitamos, pero no el objeto programa. El objeto programa es el que se usa para ejecutar 
los shaders en la GPU. **¬øCu√°l es el c√≥digo de los shaders?**

**Vertex shader:**

``` glsl
#version 460 core
layout(location = 0) in vec3 aPos;
void main() {
	gl_Position = vec4(aPos, 1.0);
}
```

**Fragment shader:**

``` glsl
#version 460 core
out vec4 FragColor;
void main() {
	FragColor = vec4(1.0, 0.5, 0.2, 1.0);
}
```

Analicemos el c√≥digo del vertex shader. Este shader se ejecuta en la GPU y recibe los datos de los v√©rtices. En este caso, 
estamos usando un solo atributo de v√©rtice (la posici√≥n). El shader toma la posici√≥n del v√©rtice y la convierte en un vector 
de cuatro componentes (x, y, z, w). El componente w se establece en 1.0 porque estamos trabajando en un espacio de coordenadas 
homog√©neo. Luego, el shader asigna este vector a la variable `gl_Position`, que es una variable predefinida en OpenGL que 
representa la posici√≥n del v√©rtice en el espacio de clip. El espacio de clip (clip space) es el espacio de coordenadas justo 
antes de que OpenGL haga el clipping y la proyecci√≥n en pantalla. En otras palabras: es el espacio donde deben estar las 
posiciones de los v√©rtices antes de ser recortados por el frustum de visi√≥n (el volumen visible de la c√°mara) y antes de 
transformarse en coordenadas de pantalla (viewport).

Miremos ahora en detalle cada l√≠nea de c√≥digo del vertex shader:

``` glsl
#version 460 core
```

Esta l√≠nea indica la versi√≥n del lenguaje GLSL (OpenGL Shading Language) que estamos utilizando. En este caso, estamos 
usando la versi√≥n 460 core, que es una de las versiones m√°s recientes y estables.

``` glsl
layout(location = 0) in vec3 aPos;
```

Esta l√≠nea define un atributo de entrada llamado `aPos` que representa la posici√≥n del v√©rtice. La palabra clave 
`layout(location = 0)` indica que este atributo se asigna a la ubicaci√≥n 0 en el buffer de atributos. Esto es importante 
porque OpenGL utiliza estas ubicaciones para vincular los atributos de los v√©rtices con los datos en el buffer de v√©rtices.

``` glsl
void main() {
```
Esta l√≠nea define la funci√≥n principal del shader. Esta funci√≥n se ejecuta para cada v√©rtice que se procesa en el pipeline de OpenGL.

``` glsl
gl_Position = vec4(aPos, 1.0);
```

Esta l√≠nea asigna la posici√≥n del v√©rtice a la variable predefinida `gl_Position`. La funci√≥n `vec4(aPos, 1.0)` convierte 
el vector de tres componentes `aPos` en un vector de cuatro componentes, donde el cuarto componente (w) se establece en 1.0. 
Esto es necesario porque OpenGL trabaja con coordenadas homog√©neas y necesita un vector de cuatro componentes para representar 
la posici√≥n del v√©rtice en el espacio de clip.

El shader de fragmentos se ejecuta despu√©s del vertex shader y recibe los datos de los fragmentos. En este caso, estamos 
asignando un color fijo (naranja) a la variable `FragColor`, que es una variable de salida predefinida en OpenGL que 
representa el color del fragmento. Este color se utiliza para dibujar el tri√°ngulo en la pantalla.

``` glsl
#version 460 core
out vec4 FragColor;
```

Esta l√≠nea indica la versi√≥n del lenguaje GLSL (OpenGL Shading Language) que estamos utilizando. La 
variable `FragColor` es una variable de salida que representa el color del fragmento.

``` glsl
void main() {
```
Esta l√≠nea define la funci√≥n principal del shader. Esta funci√≥n se ejecuta para cada fragmento que se procesa en el pipeline de OpenGL.

``` glsl
FragColor = vec4(1.0, 0.5, 0.2, 1.0);
```
Esta l√≠nea asigna un color fijo (naranja) a la variable `FragColor`. La funci√≥n `vec4(1.0, 0.5, 0.2, 1.0)` crea un vector de 
cuatro componentes que representa el color en formato RGBA (rojo, verde, azul y alfa). En este caso, el color es un naranja 
claro con un valor alfa de 1.0 (completamente opaco).

:::note[üßê‚úçÔ∏è Reporta en tu bit√°cora]
Es momento de hacer digesti√≥n cognitiva. Debemos parar de nuevo en este punto y consolidar. Para ello te pedir√© 
que hagas lo siguiente:
1.  Escribe un resumen en tus propias palabras de lo que se necesita para dibujar un tri√°ngulo en OpenGL.
2.  Escribe un resumen en tus propias palabras de lo que necesitas para poder usar un shader en OpenGL.
:::

Volvamos al asunto del ``glVertexAttribPointer`` ¬øRecuerdas? Te promet√≠ que lo retomar√≠amos. Pero ahora que 
ya sabes un poco m√°s de OpenGL, te voy a proponer algo m√°s. Sup√≥n que vas a definir un VBO con tres atributos y 
la idea es usar un shader diferente en cada draw call. Por ejemplo, el primer shader va a usar la posici√≥n, el 
segundo shader va a usar el color y el tercer shader va a usar el offset. Es decir, en cada shader vas a usar un 
atributo diferente. En este caso, el VBO tendr√≠a tres atributos:

1.  Posici√≥n (x, y, z)
2.  Color (r, g, b)
3.  Offset (u, v)

Estos ser√°n los v√©rtices:

```cpp
float vertices[] = {
	//  pos         color         offset
	-1.0f, -1.0f, 0.0f,   0.0f, 0.0f, 0.0f,   0.1f, 0.5f,
		0.0f, -1.0f, 0.0f,   1.0f, 0.0f, 0.0f,   0.2f, 0.5f,
		-0.5f,  -0.5f, 0.0f,   0.5f, 0.5f, 0.0f,   0.15f, 0.75f,
};
```

Estos ser√≠an los 3 shaders:

Shader A:

``` glsl
layout(location = 0) in vec3 aPos;

void main() {
    gl_Position = vec4(aPos, 1.0);
}

```

Shader B:

``` glsl
layout(location = 1) in vec3 aColor;

void main() {
    gl_Position = vec4(aColor * 0.5, 1.0); // usar color como posici√≥n "falsa"
}

```
Shader C:

``` glsl
layout(location = 2) in vec2 aOffset;

void main() {
    gl_Position = vec4(aOffset, 0.0, 1.0);
}
```

Ahora, al momento de hacer la configuraci√≥n del VAO y el VBO har√≠as esto:

```cpp
GLuint VAO, VBO;
glGenVertexArrays(1, &VAO);
glGenBuffers(1, &VBO);

glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

// Atributo 0: posici√≥n
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(0));
glEnableVertexAttribArray(0);

// Atributo 1: color
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);

// Atributo 2: offset
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
glEnableVertexAttribArray(2);

glBindVertexArray(0);
```

De nuevo, gr√°ficamente:

![VBO con 3 atributos](../../../assets/VBO-3Attrs.webp)

Ya al momento de hacer el render har√≠as algo como esto:

```cpp
glBindVertexArray(VAO);

// 1. Usar solo el atributo 0 (posici√≥n)
glUseProgram(shaderA);
glEnableVertexAttribArray(0);
glDisableVertexAttribArray(1);
glDisableVertexAttribArray(2);
glDrawArrays(GL_TRIANGLES, 0, 3);

// 2. Usar solo el atributo 1 (color)
glUseProgram(shaderB);
glDisableVertexAttribArray(0);
glEnableVertexAttribArray(1);
glDisableVertexAttribArray(2);
glDrawArrays(GL_TRIANGLES, 0, 3);

// 3. Usar solo el atributo 2 (offset)
glUseProgram(shaderC);
glDisableVertexAttribArray(0);
glDisableVertexAttribArray(1);
glEnableVertexAttribArray(2);
glDrawArrays(GL_TRIANGLES, 0, 3);
```

¬øPudiste notar entonces c√≥mo se usa glEnableVertexAttribArray? Observa que en cada draw call habilitamos solo el atributo que vamos a usar. 

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Implementa el c√≥digo anterior en tu m√°quina y captura pantalla del resultado. Pero antes de hacerlo 
trata de predecir qu√© va a pasar.
:::

### Actividad 05

#### Tri√°ngulo interactivo

:::note[üéØ Enunciado]
En esta actividad vas a modificar el ejemplo del tri√°ngulo simple para que sea interactivo.
La idea es que puedas cambiar el color del tri√°ngulo y su posici√≥n en la pantalla pasando 
informaci√≥n desde el c√≥digo C++ a los shaders. 
:::

Lo que vamos a hacer es modificar el c√≥digo C++ para que pase informaci√≥n a los shaders de modo 
que el tri√°ngulo cambie de color y posici√≥n dependiendo de la posici√≥n del mouse.
Vamos a usar un `uniform` para pasar la posici√≥n del mouse y otro `uniform` para el color.

**¬øQu√© es un uniform?**
Un `uniform` es una variable global de solo lectura dentro del shader, que puede ser establecida 
desde el c√≥digo C++ antes del draw call y permanece constante durante la ejecuci√≥n de un draw call. 

A diferencia de los atributos de v√©rtices, que son espec√≠ficos para cada v√©rtice, los `uniforms` 
son globales y son **√∫nicos para cada shader object**, pero pueden ser compartidos entre diferentes 
shaders en el mismo programa, es decir, pueden ser usados en diferentes etapas del pipeline de OpenGL.

Vamos a modificar los vertex y fragment shaders para que acepten estos `uniforms` y los utilicen para cambiar el color 
y la posici√≥n del tri√°ngulo:

```glsl
#version 460 core

layout(location = 0) in vec3 aPos;
uniform vec2 offset;

void main() {
    vec3 newPos = aPos;
    newPos.x += offset.x;
    newPos.y += offset.y;
    gl_Position = vec4(newPos, 1.0);
}
```

```glsl
#version 460 core

out vec4 FragColor;
uniform vec4 ourColor;

void main() {
    FragColor = ourColor;
}
```
En el vertex shader, estamos usando un `uniform` llamado `offset` para modificar la posici√≥n del tri√°ngulo.
En el fragment shader, estamos usando un `uniform` llamado `ourColor` para modificar el color del tri√°ngulo.

Ahora vamos a modificar el c√≥digo C++ para que pase estos `uniforms` a los shaders. Justo antes del loop 
de renderizado, vamos a obtener la ubicaci√≥n de los `uniforms` y pasarlos al shader:

```cpp
glUseProgram(shaderProg);
int offsetLocation = glGetUniformLocation(shaderProg, "offset");
int colorLocation = glGetUniformLocation(shaderProg, "ourColor");
```
Luego, dentro del loop de renderizado, vamos a actualizar los `uniforms` con la posici√≥n del mouse y el color:

```cpp
// Dibuja el tri√°ngulo
double xpos, ypos;
glfwGetCursorPos(mainWindow, &xpos, &ypos);

// Normalizo las coordenadas del mouse
float x = (float)xpos / (float)SCR_WIDTH;
x < 0 ? x = 0 : x;
x > 1 ? x = 1 : x;

float y = (float)ypos / (float)SCR_HEIGHT;
y < 0 ? y = 0 : y;
y > 1 ? y = 1 : y;

// Envio el color y la posici√≥n del tri√°ngulo
float color[] = { x, y, 0.0f, 1.0f };
glUniform4f(colorLocation, x, y, 0.0f, 1.0f);

// Envio el offset del tri√°ngulo normalizado a NDC
glUniform2f(offsetLocation, x*2 - 1, 1 - y*2);


glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES, 0, 3);

// Intercambia buffers y muestra el contenido
glfwSwapBuffers(mainWindow);

```
En este c√≥digo, estamos obteniendo la posici√≥n del mouse y normaliz√°ndola para que est√© entre 0 y 1.
Luego, estamos enviando el color y la posici√≥n del tri√°ngulo al shader usando los `uniforms` que definimos
anteriormente.
Finalmente, estamos dibujando el tri√°ngulo y actualizando la pantalla.

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
1. Modifica el c√≥digo del tri√°ngulo para que sea interactivo.
2. Incluye una captura de pantalla del tri√°ngulo interactivo funcionando en tu m√°quina.
3. Explica el proceso de normalizaci√≥n de las coordenadas del mouse y c√≥mo se relaciona con el sistema de coordenadas de OpenGL.
4. Explica el proceso de normalizaci√≥n a coordenadas de dispositivo (NDC) y c√≥mo se relaciona con el sistema de coordenadas de OpenGL.
:::


## Apply: Aplicaci√≥n üõ†

En esta fase vas a aplicar lo que aprendiste en la fase de investigaci√≥n.
Te voy a proponer un problema sencillo para que repases los conceptos de la 
fase de investigaci√≥n.

### Actividad 06

#### Aplica lo aprendido en esta unidad

:::note[üéØ Enunciado]
¬°Es hora de poner en pr√°ctica lo aprendido! En la actividad anterior, hiciste que el tri√°ngulo respondiera a la posici√≥n del 
mouse. Ahora, vamos a dar un paso m√°s all√° y a introducir un elemento din√°mico que no dependa directamente de tu interacci√≥n: el tiempo.

Tu misi√≥n es modificar el ejemplo del tri√°ngulo simple (puedes partir del resultado de la Actividad 05 o del original) para que su color cambie autom√°ticamente a lo largo del tiempo, creando un efecto pulsante o c√≠clico.
:::

**Pistas:**

1.  **Necesitas obtener el tiempo:** la biblioteca GLFW proporciona una funci√≥n muy √∫til para esto: `glfwGetTime()`. Esta funci√≥n devuelve el tiempo en segundos (como un `double`) desde que se inicializ√≥ GLFW.
2.  **Pasar el tiempo al shader:** ¬øC√≥mo puedes enviar informaci√≥n desde tu c√≥digo C++ al shader, informaci√≥n que es la misma para todos los v√©rtices y fragmentos en un **draw call** espec√≠fico?
3.  **Modificar el color en el shader:** dentro del `main()` de tu *fragment shader*, ya no usar√°s un color fijo ni depender√°s directamente del `uniform` del mouse (si partiste de la Actividad 05). Ahora, usar√°s el `uniform` del tiempo para calcular el color.
    *   **Idea:** Las funciones trigonom√©tricas como `sin()` o `cos()` son excelentes para crear ciclos suaves. Por ejemplo, `(sin(time) + 1.0) / 2.0` produce un valor que oscila suavemente entre 0.0 y 1.0. Puedes usar esto para modular uno o m√°s componentes (R, G, B) del color. ¬°Experimenta!

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]

1.  Describe brevemente los cambios que realizaste en el c√≥digo C++ (d√≥nde obtienes el tiempo, c√≥mo y d√≥nde actualizas el uniform).
2.  Pega el c√≥digo modificado de tu *fragment shader*.
3.  Explica c√≥mo usaste la funci√≥n de tiempo (`sin`, `cos`, u otra) para lograr el efecto de cambio de color c√≠clico. ¬øQu√© rango de valores produce tu c√°lculo y c√≥mo afecta eso al color final?
4.  Incluye una captura de pantalla o **UN ENLACE** a un video mostrando el resultado del tri√°ngulo con color cambiante.
5.  **Reflexi√≥n:** ¬øQu√© otros efectos visuales simples podr√≠as lograr usando el tiempo como `uniform`? Piensa en la posici√≥n, el tama√±o o la rotaci√≥n (aunque no hemos visto rotaciones formalmente, ¬°intuitivamente podr√≠as intentarlo!). Anota al menos una idea.
:::

## Evidencias üóÇÔ∏è

<Aside type="note" title="RUBRICA!">
* Recuerda que la bit√°cora se cierra el 16 de octubre de 2025 a las 7:49 a.m. No olvides que el aprendizaje es un proceso que se 
plasma en la bit√°cora. La bit√°cora no es un resultado que se llena a √∫ltima hora.
* Si no realizas la autoevaluaci√≥n tu nota ser√° 0.
* Si una actividad no est√° COMPLETA debes multiplicar la nota de esa actividad por el porcentaje de avance que tengas.
* Si usas IA para generar c√≥digo, texto o im√°genes la nota en esa actividad ser√° 0.

**R√∫brica de evaluaci√≥n del proceso**

5: realice las 6 actividades completas y la autoevaluaci√≥n.  
4: realic√© 5 actividades completas y la autoevaluaci√≥n.  
3: realic√© 4 actividades completas y la autoevaluaci√≥n.  
2: realic√© 3 actividades completas y la autoevaluaci√≥n.  
1: realic√© 2 actividades completas y la autoevaluaci√≥n.  
0.5: realic√© 1 actividad completa y la autoevaluaci√≥n.  
0: no realic√© ninguna actividad o no realic√© la autoevaluaci√≥n.  
</Aside>

<Aside type="danger" title="EVIDENCIAS EN BIT√ÅCORA">

1. Realiza las actividades propuestas en esta unidad y documenta todo el proceso en tu bit√°cora.
2. Realiza la autoevaluaci√≥n indicando:
    * Tu nota propuesta.
    * La defensa de esa nota para cada actividad. 
</Aside>

## Reflect: Consolidaci√≥n y metacognici√≥n ü§î

1. En una hoja de papel o un white board digital te pedir√© que hagas un inventario de todo los 
conceptos de esta unidad que puedas recordar. Luego construye un diagrama donde ubiques todos los conceptos, tratando 
de agruparlos y relacionarlos entre s√≠. 
2. Preg√∫ntate: ¬øQu√© conceptos domino bien? ¬øCu√°les me cuestan m√°s trabajo?
3. Preg√∫ntate para qu√© pueden servirte estos conceptos.
4. ¬øQu√© hiciste bien en esta unidad que debes continuar haciendo?
5. ¬øQu√© deber√≠as comenzar a hacer para mejorar tu proceso?
6. Formula tu plan de acci√≥n personal para abordar aquello que te cueste m√°s trabajo.