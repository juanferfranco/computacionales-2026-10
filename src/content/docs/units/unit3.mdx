---
title: Unidad 3
unitId: unit3
---

:::danger[NO DEBES USAR IA PARA REALIZAR LAS ACTIVIDADES DE ESTA UNIDAD]
Lo que busco con esta unidad es que transformes tu cerebro mediante  
un PROCESO cognitivo de experimentaci贸n, observaci贸n, reflexi贸n y 
conclusi贸n: INVESTIGACIN EN ACCIN. Lo que cambia tu cerebro no es 
el resultado, es el PROCESO.
:::

## Introducci贸n 

En las unidades anteriores exploraste la programaci贸n de computadores desde una perspectiva de bajo 
nivel mediante el lenguaje ensamblador. Luego comenzaste a conectar el lenguaje ensamblador con algunas 
expresiones de alto nivel. En esta unidad, vas a revisar algunos conceptos de la programaci贸n en 
alto nivel, en particular el manejo de la memoria.

Es muy importante que dediques tiempo de calidad a cada una de las actividades, experimenta con los c贸digos, 
modifica, prueba, equiv贸cate, aprende de tus errores. Te pedir茅 que lances hip贸tesis 
acerca de lo que est谩 ocurriendo, que observes, analices y reflexiones sobre los resultados. Este es un proceso 
de Investigaci贸n en acci贸n en el que aprender谩s a trav茅s de la experimentaci贸n y la reflexi贸n.

## Set: 驴Qu茅 aprender谩s en esta unidad? 

En esta fase comenzar谩s la exploraci贸n de uno de los lenguajes de programaci贸n m谩s importantes en la industria 
del entretenimiento digital: C++. Sin embargo, nuestro objetivo no es aprender C++, no es el fin, C++ ser谩 el medio 
a trav茅s del cual explorar谩s algunos conceptos b谩sicos que ya has usado (C#), pero que ahora analizar谩s m谩s a fondo.

## Seek: Investigaci贸n 

### Actividad 01

#### Hola mundo

Vas a familiarizarte con el entorno de desarrollo y comenzar谩s 
a explorar algunos conceptos b谩sicos de programaci贸n en C++.

- Abre Visual Studio (no lo confundas con Visual Studio Code).
- Crea un nuevo proyecto de consola en C++. 驴C贸mo se hace esto? 
Simplemente selecciona la opci贸n crear un nuevo proyecto. Selecciona el lenguaje C++ y la plataforma 
Windows. Luego selecciona la plantilla de aplicaci贸n de consola de Windows.

![Console app](../../../assets/consoleTemplate.png)

Una vez crees el proyecto abre el archivo .cpp que contiene la funci贸n main. 
(En el men煤 View selecciona Solution Explorer y luego haz doble clic en el archivo .cpp).

Deber铆as ver algo as铆:

```cpp

#include <iostream>

int main()
{
    std::cout << "Hello World!\n";
}
```

Ejecuta el c贸digo presionando F5. Deber铆as ver algo as铆:

![Hello World](../../../assets/helloWorld.png)

Ahora, modifica el c贸digo para que imprima el resultado de la suma de dos n煤meros enteros. 
Dicha suma la realizar谩 una funci贸n que se llamar谩 `sum`. La funci贸n `sum` recibir谩 dos
par谩metros enteros y devolver谩 la suma de los dos n煤meros. 

```cpp
#include <iostream>

int sum(int a, int b)
{
    return a + b;
}

int main()
{
    int a = 5;
    int b = 7;
    std::cout << "La suma de " << a << " y " << b << " es " << sum(a, b) << "\n";
}
```

Ejecuta el c贸digo y verifica que el resultado sea correcto.

Por 煤ltimo te pedir茅 que ejecutes paso a paso el c贸digo. Para hacer esto, coloca 
un breakpoint en la l铆nea que contiene la definici贸n de la variable `a`, as铆:

![Breakpoint](../../../assets/breakpoint.png)

Presiona F5 y luego F10 para ejecutar paso a paso el c贸digo. Observa c贸mo 
cambian las variables en la pesta帽a Autos (podr谩s ver esta pesta帽a en la parte inferior, 
la puedes activar en el men煤 Debug -> Windows -> Autos) as铆:

![Autos](../../../assets/autos.png)

En la esquina superior derecha podr谩s ver las opciones de depuraci贸n:

![Debug](../../../assets/debug.png)

Familiar铆zate con estas opciones, te ser谩n de mucha utilidad en el futuro.

Reflexi贸n final de esta actividad:

1. 驴Para qu茅 sirven los breakpoints?
2. 驴Para qu茅 se usa la ventana de depuraci贸n Autos?

### Actividad 02

#### Paso por valor y paso por referencia

Analizaremos el concepto de paso de par谩metros en C++ y c贸mo se comporta el 
paso por valor, por referencia y por puntero.

``` cpp
#include <iostream>

using namespace std;

// Funci贸n que modifica el par谩metro pasado por valor
void modificarPorValor(int n) {
    cout << "Dentro de modificarPorValor, valor inicial: " << n << endl;
    n += 5;
    cout << "Dentro de modificarPorValor, valor modificado: " << n << endl;
}

// Funci贸n que modifica el par谩metro pasado por referencia
void modificarPorReferencia(int &n) {
    cout << "Dentro de modificarPorReferencia, valor inicial: " << n << endl;
    n += 5;
    cout << "Dentro de modificarPorReferencia, valor modificado: " << n << endl;
}

// Funci贸n que modifica el par谩metro utilizando punteros
void modificarPorPuntero(int *n) {
    cout << "Dentro de modificarPorPuntero, valor inicial: " << *n << endl;
    *n += 5;
    cout << "Dentro de modificarPorPuntero, valor modificado: " << *n << endl;
}

int main() {
    int a = 10;
    int b = 10;
    int c = 10;

    cout << "Valor inicial de a (paso por valor): " << a << endl;
    cout << "Valor inicial de b (paso por referencia): " << b << endl;
    cout << "Valor inicial de c (paso por puntero): " << c << endl;

    cout << "\nLlamando a modificarPorValor(a)..." << endl;
    modificarPorValor(a);
    cout << "Despu茅s de modificarPorValor, valor de a: " << a << endl;

    cout << "\nLlamando a modificarPorReferencia(b)..." << endl;
    modificarPorReferencia(b);
    cout << "Despu茅s de modificarPorReferencia, valor de b: " << b << endl;

    cout << "\nLlamando a modificarPorPuntero(&c)..." << endl;
    modificarPorPuntero(&c);
    cout << "Despu茅s de modificarPorPuntero, valor de c: " << c << endl;

    return 0;
}
```

- Predicci贸n: antes de ejecutar el programa, predice la salida de cada funci贸n y explica el resultado.
- 驴Qu茅 diferencias observas en el comportamiento de a, b y c tras cada llamada?
- 驴Por qu茅 ocurre esta diferencia?

Analicemos el c贸digo l铆nea por l铆nea y expliquemos en detalle qu茅 sucede en cada funci贸n y c贸mo se comporta el paso de par谩metros de diferentes maneras.

1. Inclusi贸n de librer铆as y uso del espacio de nombres:

``` cpp
#include <iostream>
using namespace std;
```

- iostream: es la librer铆a est谩ndar de C++ para poder usar cout y otras funcionalidades de entrada/salida.  
- using namespace std;: permite usar los elementos del espacio de nombres std directamente, 
sin tener que escribir std:: cada vez como en la actividad anterior.  

2. Funci贸n modificarPorValor

``` cpp	
void modificarPorValor(int n) {
    cout << "Dentro de modificarPorValor, valor inicial: " << n << endl;
    n += 5;
    cout << "Dentro de modificarPorValor, valor modificado: " << n << endl;
}

```

Paso por Valor:

- Par谩metro: la funci贸n recibe n por valor. Esto significa que se hace una copia del valor de la variable que se pasa desde main().  
- Efecto: las modificaciones que se realizan en n dentro de la funci贸n no afectan a la variable original, ya que se trabaja sobre una copia.  
- Salida: dentro de la funci贸n se imprimen dos mensajes: uno antes y otro despu茅s de sumar 5 a n. Sin embargo, fuera de la funci贸n, la variable original permanece igual.  

3. Funci贸n modificarPorReferencia

``` cpp
void modificarPorReferencia(int &n) {
    cout << "Dentro de modificarPorReferencia, valor inicial: " << n << endl;
    n += 5;
    cout << "Dentro de modificarPorReferencia, valor modificado: " << n << endl;
}
```

Paso por Referencia (con Referencias):

- Par谩metro: se declara int &n, lo que significa que n es una referencia a la variable original.  
- Efecto: la variable n en la funci贸n es un alias de la variable pasada. Cualquier cambio realizado en n afecta directamente a la variable original.  
- Salida: la suma de 5 a n dentro de la funci贸n modifica la variable original, y esto se refleja fuera de la funci贸n.  

4. Funci贸n modificarPorPuntero

``` cpp
void modificarPorPuntero(int *n) {
    cout << "Dentro de modificarPorPuntero, valor inicial: " << *n << endl;
    *n += 5;
    cout << "Dentro de modificarPorPuntero, valor modificado: " << *n << endl;
}
```	

Paso por Puntero:

- Par谩metro: la funci贸n recibe un puntero int *n, que contiene la direcci贸n de memoria de una variable.  
- Acceso al Valor: para acceder y modificar el valor apuntado, se utiliza el operador de indirecci贸n (*).  
- Efecto: al modificar *n, se est谩 cambiando el valor de la variable original a la que apunta el puntero.  
- Salida: al igual que en el caso de la referencia, el cambio (suma de 5) afecta directamente a la variable original.  

5. Funci贸n main

``` cpp	
int main() {
    int a = 10;
    int b = 10;
    int c = 10;
```

Se declaran y definen tres variables enteras a, b y c, todas inicializadas en 10. Cada una se utilizar谩 para evaluar uno de los m茅todos de paso de par谩metros.

``` cpp	
cout << "Valor inicial de a (paso por valor): " << a << endl;
cout << "Valor inicial de b (paso por referencia): " << b << endl;
cout << "Valor inicial de c (paso por puntero): " << c << endl;
```	

Se imprime el valor inicial de cada variable antes de cualquier modificaci贸n.

Llamada a modificarPorValor

``` cpp
cout << "\nLlamando a modificarPorValor(a)..." << endl;
modificarPorValor(a);
cout << "Despu茅s de modificarPorValor, valor de a: " << a << endl;
```

驴Qu茅 ocurre?

- Se llama a modificarPorValor(a). Dentro de la funci贸n, a se pasa por valor, lo que genera 
una copia de a.  
- Dentro de la funci贸n, se suma 5 a la copia y se imprimen los valores modificados.
- Al regresar a main(), la variable a no ha cambiado, ya que la copia modificada no afecta a la original.  

Resultado Esperado:

- Dentro de la funci贸n: valor inicial: 10 y valor modificado: 15.  
- Fuera de la funci贸n: a sigue siendo 10.  

Llamada a modificarPorReferencia

``` cpp
cout << "\nLlamando a modificarPorReferencia(b)..." << endl;
modificarPorReferencia(b);
cout << "Despu茅s de modificarPorReferencia, valor de b: " << b << endl;
```

驴Qu茅 ocurre?

- Se llama a modificarPorReferencia(b). Aqu铆, b se pasa por referencia, lo que significa que no se hace una copia: n es simplemente otro nombre para b.  
- Al sumar 5 a n dentro de la funci贸n, b se modifica directamente.

Resultado Esperado:

- Dentro de la funci贸n: valor inicial: 10 y valor modificado: 15.  
- Fuera de la funci贸n: b es 15, reflejando la modificaci贸n.  

Llamada a modificarPorPuntero

``` cpp	
cout << "\nLlamando a modificarPorPuntero(&c)..." << endl;
modificarPorPuntero(&c);
cout << "Despu茅s de modificarPorPuntero, valor de c: " << c << endl;
```

驴Qu茅 ocurre?

- Se llama a modificarPorPuntero(&c), pasando la direcci贸n de c.  
- Dentro de la funci贸n, n es un puntero a c. Usando *n, accedemos al valor de c.  
- Al sumar 5 a *n, se modifica el valor almacenado en c.  

Resultado Esperado:

- Dentro de la funci贸n: valor inicial: 10 y valor modificado: 15.
- Fuera de la funci贸n: c es 15, ya que se ha modificado directamente mediante el puntero.

6. Conclusi贸n

Paso por Valor:

La funci贸n recibe una copia del valor. Las modificaciones realizadas dentro de la funci贸n no afectan a la variable original. En este ejemplo, a sigue siendo 10 despu茅s de la llamada a modificarPorValor.

Paso por Referencia (con referencias):

La funci贸n recibe una referencia (alias) a la variable original. Las modificaciones realizadas dentro de la funci贸n afectan a la variable original. En el ejemplo, b se convierte en 15 despu茅s de la llamada a modificarPorReferencia.

Paso por Puntero:

La funci贸n recibe la direcci贸n de la variable original. Accediendo al valor mediante la indirecci贸n (*), se puede modificar el contenido de la variable original. As铆, c se convierte en 15 despu茅s de la llamada a modificarPorPuntero.

Reflexi贸n final para esta actividad:

Implementa tres versiones de una funci贸n para intercambiar (swap) los valores 
de dos variables enteras, utilizando:

- Paso por valor.  
- Paso por referencia (usando referencias).  
- Paso por puntero.  

Crea un proyecto de consola en Visual Studio. Implementa las siguientes funciones:

``` cpp	
swapPorValor(int a, int b)
```	

Esta funci贸n debe intentar intercambiar los valores de a y b pas谩ndolos por valor.
Nota: Se espera que el intercambio no afecte a las variables originales en main().

``` cpp
swapPorReferencia(int &a, int &b)
``` 

Esta funci贸n debe intercambiar los valores de a y b utilizando paso por referencia con referencias.

``` cpp
swapPorPuntero(int *a, int *b)
```	

Esta funci贸n debe intercambiar los valores de a y b utilizando punteros. Recuerda acceder a los valores con el operador de indirecci贸n (*).

1. Muestra el c贸digo con la implementaci贸n de las funciones de swap.
2. Muestra los resultados de las pruebas realizadas en la funci贸n main().

### Actividad 03

#### Mapa de memoria de un programa escrito en C++

Un programa en C++ (ya sea en Windows o en otros sistemas operativos) se organiza en diferentes secciones o segmentos de memoria. 
Aunque la implementaci贸n exacta puede variar seg煤n el compilador y el sistema operativo, la estructura general del mapa de memoria es similar.

Piensa en el mapa de memoria como un gran arreglo donde cada secci贸n tiene un prop贸sito espec铆fico. 


``` bash
+-------------------------------+
|       Segmento de c贸digo      |
|   (instrucciones, funciones)  |
+-------------------------------+
| Variables globales y est谩ticas|
+-------------------------------+
|           Heap                | <--- Asignaci贸n din谩mica (new/malloc)
|                               |
|                               |
+-------------------------------+
|           Stack               | <--- Variables locales
+-------------------------------+

``` 

A continuaci贸n, te describir茅 los segmentos de memoria m谩s comunes en un programa C++:


1. Segmento de c贸digo (o Text). Es la zona de memoria donde se encuentra el c贸digo ejecutable del programa, es decir, las instrucciones compiladas. Se caracteriza porque es de solo lectura en muchos sistemas para prevenir modificaciones accidentales o maliciosas. Contiene todas las funciones, incluyendo main(), y cualquier otra funci贸n definida en el programa.

2. Variables globales y est谩ticas: aqu铆 se almacenan las variables globales y est谩ticas que han sido inicializadas expl铆citamente y 
tambi茅n las que no han sido inicializadas.

3. Heap: es el 谩rea de memoria utilizada para la asignaci贸n din谩mica de memoria en tiempo de ejecuci贸n. Se gestiona manualmente mediante funciones como new y delete en C++.

4. Stack: es la regi贸n de memoria donde se almacenan las variables locales y la informaci贸n de control de las funciones (como direcciones de retorno, par谩metros y variables locales). La asignaci贸n y liberaci贸n de memoria en el stack se hace de manera autom谩tica al entrar y salir de las funciones. Su tama帽o es limitado y, en caso de usar demasiada memoria local, puede 
producirse un stack overflow. Las variables definidas en el stack tienen un tiempo de vida limitado al alcance de la funci贸n 
o bloque en que se definen.

Ahora te mostrar茅 un ejemplo donde tratar茅 de ejemplificar el uso de cada uno de estos segmentos de memoria. 

```cpp
#include <iostream>
#include <cstdlib>

using namespace std;

// Variables globales
int global_inicializada = 42;      
int global_no_inicializada;        

// Constante global
const char* const mensaje_ro = "Hola, memoria de solo lectura";

// Funci贸n de ejemplo que muestra la direcci贸n de su variable local est谩tica
void funcionConStatic() {
    static int var_estatica = 100;
    cout << "Direcci贸n de var_estatica (static): " << &var_estatica << endl;
}

// Funci贸n que asigna memoria din谩mica (heap)
int* crearArrayHeap(int tam) {
    int* arr = new int[tam];
    for (int i = 0; i < tam; i++) {
        arr[i] = i;
    }
    return arr;
}

// Una funci贸n simple para representar el c贸digo (se encontrar谩 en la regi贸n de c贸digo)
int suma(int a, int b) {
    int c = a + b; // "c" es una variable local (stack)
    return c;
}

int main() {
    // Variable local (stack)
    int a = 10;
    int b = 20;
    int c = suma(a, b);

    cout << "Resultado de suma(a, b): " << c << endl;
    cout << "Direcci贸n de variable local 'a': " << &a << endl;
    cout << "Direcci贸n de variable local 'b': " << &b << endl;
    cout << "Direcci贸n de la variable local 'c' (resultado): " << &c << endl;

    // Variables globales
    cout << "Direcci贸n de 'global_inicializada': " << &global_inicializada << endl;
    cout << "Direcci贸n de 'global_no_inicializada': " << &global_no_inicializada << endl;

    // Constante global (solo lectura)
    cout << "Direcci贸n de 'mensaje_ro' (zona de solo lectura): " << static_cast<const void*>(mensaje_ro) << endl;

    // Llamada a funci贸n que tiene variable est谩tica
    funcionConStatic();

    // Uso del Heap: asignaci贸n din谩mica
    int tamArray = 10;
    int* arrayHeap = crearArrayHeap(tamArray);
    cout << "Direcci贸n del primer elemento del array asignado en Heap: " << arrayHeap << endl;
    for (int i = 0; i < tamArray; i++) {
        cout << "arrayHeap[" << i << "] = " << arrayHeap[i]
            << " en " << (arrayHeap + i) << endl;
    }
    delete[] arrayHeap; // Liberamos la memoria din谩mica

    return 0;
}
```

Reflexi贸n final para esta actividad:

Revisa de nuevo el programa anterior y construye tu propio mapa de memoria indicando en qu茅 parte del 
mapa se ubican las variables y constantes globales, locales, est谩ticas y de la memoria din谩mica y en 
qu茅 parte del mapa se encuentran las funciones y el mensaje de solo lectura.

### Actividad 04 

#### Experimentos

Vas a realizar m煤ltiples experimentos con el c贸digo de la actividad anterior para comprender c贸mo se comportan 
los segmentos de memoria en un programa C++.

Experimento 1: modificar el segmento de texto:

``` cpp
#include <iostream>
#include <cstdlib>

using namespace std;


int main() {
    // Variable local (stack)
    int a = 10;
    int b = 20;

    /**********************************************************
        EXPERIMENTO 1
    ***********************************************************/

    void* ptr = reinterpret_cast<void*>(&main);
    cout << "Voy a modificar la memoria en la direcci贸n: " << ptr << endl;
    *reinterpret_cast<int*>(ptr) = 0;

    /********************************************************/

    return 0;
}
```

- 驴Qu茅 ocurre? 驴Por qu茅?

Experimento 2: modificar el segmento de datos (constante global):

``` cpp
#include <iostream>
#include <cstdlib>

using namespace std;

// Constante global
const char* const mensaje_ro = "Hola, memoria de solo lectura";


int main() {
    // Variable local (stack)
    int a = 10;
    int b = 20;


    /**********************************************************
        EXPERIMENTO 2
    ***********************************************************/

    char* ptr = (char*)&mensaje_ro;
    cout << "Voy a modificar la memoria en la direcci贸n: " << ptr << endl;
    *ptr = 0;

    /********************************************************/

    return 0;
}
```

- 驴Qu茅 ocurre? 驴Por qu茅?

Experimento 3: modificar el segmento de datos (variables globales):

``` cpp
#include <iostream>
#include <cstdlib>

using namespace std;

// Variables globales
int global_inicializada = 42;
int global_no_inicializada;


int main() {
    // Variable local (stack)
    int a = 10;
    int b = 20;

    /**********************************************************
        EXPERIMENTO 3
    ***********************************************************/

    cout << "global_inicializada: " << global_inicializada << endl;
    cout << "global_no_inicializada: " << global_no_inicializada << endl;


    global_inicializada = 69;
    global_no_inicializada = 666;

    cout << "global_inicializada: " << global_inicializada << endl;
    cout << "global_no_inicializada: " << global_no_inicializada << endl;

    /********************************************************/

    return 0;
}

```

- 驴Qu茅 ocurre? 驴Por qu茅?

Experimento 4: modificar la variable local est谩tica de una funci贸n por fuera de ella:

``` cpp
#include <iostream>
#include <cstdlib>

using namespace std;

// Funci贸n de ejemplo que muestra la direcci贸n de su variable local est谩tica
void funcionConStatic() {
    static int var_estatica = 100;
    cout << "Direcci贸n de var_estatica (static): " << &var_estatica << endl;
}


int main() {
    // Variable local (stack)
    int a = 10;
    int b = 20;

    /**********************************************************
        EXPERIMENTO 4
    ***********************************************************/

    var_estatica = 42;

    cout << "var_estatica: " << var_estatica << endl;

    /********************************************************/
    return 0;
}
``` 

- 驴Qu茅 ocurre? 驴Por qu茅?
- 驴Qu茅 pasa con las variables cada que entras y sales de la funci贸n?
- En relaci贸n a la pregunta anterior 驴Qu茅 pasa con las variables locales est谩ticas?

Experimento 5: variables locales est谩tica vs no est谩tica:

``` cpp
#include <iostream>
#include <cstdlib>

using namespace std;

// Funci贸n de ejemplo que muestra la direcci贸n de su variable local est谩tica
void funcionConStatic() {
    static int var_estatica = 100;
    cout << "var_estatica: " << var_estatica << endl;
    var_estatica++;
}

void funcionSinStatic() {
    int var_no_estatica = 100;
    cout << "var_no_estatica: " << var_no_estatica << endl;
    var_no_estatica++;
}


int main() {
    // Variable local (stack)
    int a = 10;
    int b = 20;

    /**********************************************************
        EXPERIMENTO 5
    ***********************************************************/

    for (int i = 0; i < 5; i++) {
        cout << "Iteraci贸n " << i << endl;
        funcionSinStatic();
        funcionConStatic();
    }

    /********************************************************/

    return 0;
}

```

- 驴Qu茅 ocurre? 驴Por qu茅?
- Ves alguna diferencia entre las variables locales est谩ticas y no est谩ticas?
- 驴Qu茅 pasa con las variables cada que entras y sales de la funci贸n?

Experimento 6: modificar el segmento de heap:


``` cpp	
#include <iostream>
using namespace std;

int main() {
    // Tama帽o del arreglo din谩mico
    int tam = 5;

    // Asignar memoria en el Heap para un arreglo de enteros
    int* arrayHeap = new int[tam];

    // Inicializar y mostrar los valores y direcciones de memoria
    for (int i = 0; i < tam; i++) {
        arrayHeap[i] = (i + 1) * 10;
        cout << "arrayHeap[" << i << "] = " << arrayHeap[i]
            << " en direcci贸n " << (arrayHeap + i) << endl;
    }

    // Liberar la memoria asignada en el Heap
    delete[] arrayHeap;

    /**********************************************************
        EXPERIMENTO 6
    ***********************************************************/

    cout << arrayHeap[0] << endl;


    /********************************************************/


    return 0;
}

```

- 驴Qu茅 ocurre? 驴Por qu茅? 
- Comenta la l铆nea de genera el error y analiza las siguientes preguntas:

    - 驴Qu茅 diferencias notas entre el comportamiento y la gesti贸n del Heap en comparaci贸n con el Stack?
    - 驴Qu茅 consecuencias tendr铆a no liberar la memoria reservada con new?
    - 驴Por qu茅 es importante usar delete[] al liberar memoria asignada para un arreglo?


### Actividad 05

#### Copia de objetos y su ubicaci贸n en memoria

Implementa un experimento para observar lo que ocurre al copiar un objeto. Ejecuta el programa y 
observa el comportamiento en el depurador para que puedas concluir.

Modifica la clase Punto:

``` cpp
#include <iostream>
#include <string>
using namespace std;

class Punto {
public:
	string name;
    int x;
    int y;

    // Constructor
    Punto(string _name, int _x, int _y) : name(_name),x(_x), y(_y) {
        cout << "Constructor: Punto "<< name <<" (" << x << ", " << y << ") creado." << endl;
    }

    // Destructor
    ~Punto() {
        cout << "Destructor: Punto " << name << "(" << x << ", " << y << ") destruido." << endl;
    }

    // M茅todo para imprimir valores
    void imprimir() {
        cout << "Punto "<< name << "(" << x << ", " << y << ")" << endl;
    }
};


int main() {
    // Objeto original
    Punto original("original",70, 80);
    original.imprimir();
    Punto* p = &original;

    // Copia del objeto
    Punto copia = original;
    copia.name = "copia";
    copia.x = 100;
    copia.y = 200;
    copia.imprimir();
    original.imprimir();

    p->name = "p";
    p->x = 300;
    p->y = 400;
    p->imprimir();
    original.imprimir();
    
    return 0;
}
```

Compara con C# (puedes crear un nuevo proyecto de consola C# en una nueva ventana de Visual Studio):

``` csharp
using System;

public class Punto
{
    public int x;
    public int y;
    public string name;

    // Constructor
    public Punto(string _name, int _x, int _y)
    {
        name = _name;
        x = _x;
        y = _y;
        Console.WriteLine($"Constructor: Punto {name}({x}, {y}) creado.");
    }

    // M茅todo para imprimir valores
    public void Imprimir()
    {
        Console.WriteLine($"Punto {name}({x}, {y})");
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Objeto original
        Punto original = new Punto("original",70, 80);
        original.Imprimir();

        Punto copia = original;
        copia.name = "copia";
        copia.x = 100;
        copia.y = 200;
        copia.Imprimir();
        original.Imprimir();

        // Coloca breakpoints en la creaci贸n de 'original' y en la l铆nea de la copia.
        // Observa que 'copia' es una copia independiente de 'original'.
    }
}
```

Ejecuta los programas en modo depuraci贸n y detente en los breakpoints para comparar. 

**Reflexi贸n final para esta actividad**

1. Explica qu茅 ocurre al copiar un objeto en C++ y en C#. 驴Qu茅 diferencias encuentras?
2. 驴Qu茅 es `copia` en C++ y en C#? 驴Es una copia independiente de `original`?

### Actividad integradora de investigaci贸n

:::caution[ Bit谩cora - Actividad integradora de investigaci贸n]

**Objetivo**: analizar un programa integral, predecir su comportamiento en memoria y verificar tus hip贸tesis utilizando el depurador de Visual Studio.

**Instrucciones**:

Considera el siguiente programa que combina varios de los conceptos 
que exploraste en las Actividades 01-05.

```cpp
#include <iostream>

int contador_global = 100;

void ejecutarContador() {
    static int contador_estatico = 0;
    contador_estatico++;
    std::cout << "  -> Llamada a ejecutarContador. Valor de contador_estatico: " << contador_estatico << std::endl;
}

void sumaPorValor(int a) {
    a = a + 10;
    std::cout << "  -> Dentro de sumaPorValor, 'a' ahora es: " << a << std::endl;
}

void sumaPorReferencia(int& a) {
    a = a + 10;
    std::cout << "  -> Dentro de sumaPorReferencia, 'a' ahora es: " << a << std::endl;
}

void sumaPorPuntero(int* a) {
    *a = *a + 10;
    std::cout << "  -> Dentro de sumaPorPuntero, '*a' ahora es: " << *a << std::endl;
}

int main() {
    int val_A = 20;
    int val_B = 20;
    int val_C = 20;

    std::cout << "--- Experimento con paso de par谩metros ---" << std::endl;
    std::cout << "Valor inicial de val_A: " << val_A << std::endl;
    sumaPorValor(val_A);
    std::cout << "Valor final de val_A: " << val_A << std::endl << std::endl;

    std::cout << "Valor inicial de val_B: " << val_B << std::endl;
    sumaPorReferencia(val_B);
    std::cout << "Valor final de val_B: " << val_B << std::endl << std::endl;

    std::cout << "Valor inicial de val_C: " << val_C << std::endl;
    sumaPorPuntero(&val_C);
    std::cout << "Valor final de val_C: " << val_C << std::endl << std::endl;

    std::cout << "--- Experimento con variables est谩ticas ---" << std::endl;
    ejecutarContador();
    ejecutarContador();
    ejecutarContador();

    return 0;
}
```

**Tu Tarea**:

A. Predicci贸n (sin ejecutar el c贸digo):

1. 驴Cu谩l ser谩 la salida final en la consola de este programa? 
2. Escribe la salida completa que esperas.
3. Dibuja un mapa de memoria conceptual de este programa justo 
antes de que main finalice. Debes indicar en qu茅 segmento de 
memoria (Stack, Heap, Datos Globales/Est谩ticos, C贸digo) se encontrar铆a cada 
una de las siguientes variables: contador_global, contador_estatico, val_A, 
val_B, val_C (dentro de main), el par谩metro a de la funci贸n sumaPorValor, la funci贸n main misma.


B. Verificaci贸n y an谩lisis (usando el depurador):

Ejecuta el programa paso a paso (F10) con un breakpoint al inicio de main.

4. Compara la salida real con tu predicci贸n. Si hubo diferencias, explica 
por qu茅 ocurrieron. Evidencia clave: capturas de pantalla antes y despu茅s 
de los puntos de inter茅s (驴Cu谩les son esos puntos? -> tu tarea analizarlo). 

5. Describe qu茅 demuestran estas capturas sobre la diferencia entre los 
diferentes tipos de paso por par谩metros analizados.

6. Explica con tus propias palabras el comportamiento de 
contador_estatico. 驴Por qu茅 "recuerda" su valor entre llamadas a la funci贸n 
ejecutarContador? 驴En qu茅 se diferencia de una variable local normal?

:::

## Apply: Aplicaci贸n 

### Actividad 06

#### Hola Objeto: creaci贸n de un objeto en el stack

Este experimento es fundamental porque conecta el concepto fundamental de POO (objetos) con este curso. 

Vas a crear una clase sencilla llamada Punto que represente un punto en el espacio con dos coordenadas (x e y). 
Luego, crear谩s un objeto de esta clase en el stack y utilizar谩s el depurador para inspeccionar su contenido y direcci贸n de memoria.

Pasos:

- Abre Visual Studio y crea un nuevo proyecto de consola en C++.
- Define la siguiente clase en un archivo .cpp (puedes incluir todo en main.cpp):

``` cpp
#include <iostream>
using namespace std;

class Punto {
public:
    int x;
    int y;

    // Constructor
    Punto(int _x, int _y) : x(_x), y(_y) {
        cout << "Constructor: Punto(" << x << ", " << y << ") creado." << endl;
    }

    // Destructor
    ~Punto() {
        cout << "Destructor: Punto(" << x << ", " << y << ") destruido." << endl;
    }

    // M茅todo para imprimir valores
    void imprimir() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    // Coloca un breakpoint en la siguiente l铆nea
    Punto p(10, 20);

    // Muestra el contenido del objeto
    p.imprimir();

    // Utiliza el depurador para inspeccionar 'p', observa la direcci贸n de memoria y el valor de x e y.
    return 0;
}
```

- Vas a analizar el programa anterior con su equivalente en C# (puedes crear un nuevo proyecto de consola C# en 
una nueva ventana de Visual Studio):

``` csharp
using System;

public class Punto
{
    public int x;
    public int y;

    public Punto(int _x, int _y)
    {
        x = _x;
        y = _y;
        Console.WriteLine($"Constructor: Punto({x}, {y}) creado.");
    }

    ~Punto()
    {
        Console.WriteLine($"Destructor: Punto({x}, {y}) destruido.");
    }

    public void Imprimir()
    {
        Console.WriteLine($"Punto({x}, {y})");
    }
}

class Program
{
    static void Main(string[] args)
    {
        Punto p = new Punto(10, 20);
        p.Imprimir();
    }
}
```

- Ejecuta el programa en C++ en modo depuraci贸n (F5) y coloca un breakpoint en la l铆nea donde se declara Punto p(10, 20);.
- Paso a paso (F10), observa en la ventana de variables (Autos/Locals) los valores de x y y. En el men煤 Debug, 
selecciona Windows > Memory > Memory 1 y observa la direcci贸n de memoria de `p`. Escribe en la entrada de texto de Memory 1 la direcci贸n de 
memoria de `p` as铆 `&p` y presiona Enter. Observa la direcci贸n de memoria de `p`. Observa el contenido de la memoria, deber铆as ver algunos n煤meros en hexadecimal, tales como 0a 00 00 00 14 00 00 00.
- Abre la calculadora de Windows y selecciona el modo de programador. Cambia a modo hexadecimal. Escribe 0a 驴Qu茅 valor en decimal obtienes? 
Escribe 14 驴Qu茅 valor en decimal obtienes? 驴Qu茅 observas?
- Nota el orden en el que est谩n almacenados los bytes en la memoria. Observa que el byte de menor peso (menos significativo) est谩 almacenado primero, es decir, 
en una direcci贸n de memoria menor. A esto se le conocen como arquitecturas little-endian. Otro tipo de arquitectura es big-endian, donde el byte de mayor peso (m谩s significativo) se 
almacena primero. La mayor铆a de las arquitecturas modernas son little-endian. Si la arquitectura de tu computador fuera big-endian, 驴C贸mo quedar铆an almacenados los bytes en la memoria de `p`?

**Reflexiona sobre las siguientes cuestiones**:

1. 驴Cu谩l es la diferencia entre un constructor y un destructor en C++?
2. 驴Cu谩l es la diferencia entre un objeto y una clase en C++?
3. 驴Qu茅 diferencia notas entre el objeto Punto en C++ y C#? 
4. 驴Qu茅 es `p` en C++ y qu茅 es `p` en C#? (en uno de ellos `p` es un objeto y 
en el otro es una referencia a un objeto).
5. 驴En qu茅 parte de memoria se almacena `p` en C++ y en C#?
6. 驴Qu茅 observaste con el depurador acerca de `p`? Seg煤n lo que observaste 
驴Qu茅 es un objeto en C++?

### Actividad 07

#### Objetos en el heap: creaci贸n y observaci贸n

Modifica el programa anterior para crear un objeto de la clase Punto de manera din谩mica (en el heap) utilizando new. 
Luego, inspecciona con el depurador la direcci贸n del objeto y comp谩rala con la del objeto en el stack.

``` cpp
#include <iostream>
using namespace std;

class Punto {
public:
    int x;
    int y;

    // Constructor
    Punto(int _x, int _y) : x(_x), y(_y) {
        cout << "Constructor: Punto(" << x << ", " << y << ") creado." << endl;
    }

    // Destructor
    ~Punto() {
        cout << "Destructor: Punto(" << x << ", " << y << ") destruido." << endl;
    }

    // M茅todo para imprimir valores
    void imprimir() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    // Objeto en el stack
    Punto pStack(30, 40);
    pStack.imprimir();

    // Objeto en el heap
    Punto* pHeap = new Punto(50, 60);
    pHeap->imprimir();

    // Coloca breakpoints en la creaci贸n de pStack y pHeap
    // Inspecciona las direcciones de memoria de ambos objetos:
    // - pStack: direcci贸n obtenida directamente.
    // - pHeap: la variable pHeap es un puntero que contiene la direcci贸n del objeto en el heap.

    // Recuerda liberar la memoria del heap
    delete pHeap;

    return 0;
}
```

Ejecuta el programa en modo depuraci贸n y detente en los breakpoints para comparar:

- La direcci贸n de pStack (ubicado en el stack).
- El valor de pHeap (la direcci贸n del objeto en el heap).

**Reflexiona sobre lo siguiente**:

1. Explicaci贸n de la diferencia entre objetos creados en el stack y en el heap.
2. `pStack` 驴Es un objeto o una referencia a un objeto?
3. `pHeap` 驴Es un objeto o una referencia a un objeto? Si es una referencia, 驴A qu茅 objeto hace referencia?
4. Observa en Memory1 (Debug->Windows->Memory->Memory1) el contenido de la direcci贸n de memoria de `pHeap`, recuerda escribir en la entrada de texto de Memory1 
la direcci贸n de memoria de `&pHeap` y presionar Enter. Compara el contenido de memoria con el contenido 
de `pHeap` en la pesta帽a de Locals (Debug->Windows->Locals). 驴Qu茅 observas? 驴Qu茅 significa esto?

### Actividad 08

#### Funciones y objetos en C++

Analiza, ejecuta, depura y experimenta con el siguiente c贸digo en C++.

``` cpp
#include <iostream>
#include <string>
using namespace std;

class Punto {
public:
	string name;
    int x;
    int y;

    // Constructor
    Punto(string _name, int _x, int _y) : name(_name),x(_x), y(_y) {
        cout << "Constructor: Punto "<< name <<" (" << x << ", " << y << ") creado." << endl;
    }

    // Destructor
    ~Punto() {
        cout << "Destructor: Punto " << name << "(" << x << ", " << y << ") destruido." << endl;
    }

    // M茅todo para imprimir valores
    void imprimir() {
        cout << "Punto "<< name << "(" << x << ", " << y << ")" << endl;
    }
};

void cambiarNombre(Punto p, string nuevoNombre) {
	p.name = nuevoNombre;
}

int main() {
    // Objeto original
    Punto original("original",70, 80);
    original.imprimir();
    cambiarNombre(original, "cambiado");
    original.imprimir();
    return 0;
}

```

**Reflexiona sobre lo siguiente**:

1. 驴Qu茅 ocurre despu茅s de llamar a la funci贸n `cambiarNombre`? 驴Por qu茅 aparece el mensaje `Destructor: Punto cambiado(70, 80) destruido.`? 
2. 驴Por qu茅 `original` sigue existiendo luego de llamar `cambiarNombre`?
3. 驴En qu茅 parte del mapa de memoria se encuentra `original` y en qu茅 parte se encuentra `p`? 驴Son el mismo objeto? (recuerda 
usar siempre el depurador para responder estas preguntas).

Modifica la funci贸n `cambiarNombre`:

``` cpp
void cambiarNombre(Punto& p, string nuevoNombre) {
	p.name = nuevoNombre;
}
```

4. 驴Qu茅 ocurre ahora? 驴Por qu茅?

Modifica ahora a `cambiarNombre` y a `main` de la siguiente manera:

``` cpp
void cambiarNombre(Punto* p, string nuevoNombre) {
	p->name = nuevoNombre;
}

int main() {
    // Objeto original
    Punto original("original",70, 80);
    original.imprimir();
    
    cambiarNombre(&original, "cambiado");
    original.imprimir();
    
    return 0;
}
```

5. 驴Qu茅 ocurre ahora? 驴Por qu茅?
6. En este caso 驴Cu谩l es la diferencia entre pasar un objeto por valor, por referencia y por puntero? 

### Actividad 09

#### Objetos con miembros est谩ticos y variables de instancia

Vas a analizar una clase llamada Contador que tiene:

- Un miembro de instancia, `valor`, que se incremente cada vez que se llame a un m茅todo `incrementar()`.  
- Un miembro est谩tico, `total`, que cuente cu谩ntos objetos de la clase se han creado.  

Vas a explorar c贸mo se gestionan estas variables (est谩ticas vs. no est谩ticas) en la memoria, y a utilizar el depurador para inspeccionar sus valores y direcciones.  

Pasos:

Define la clase Contador de la siguiente manera:

``` cpp
#include <iostream>
using namespace std;

class Contador {
public:
    int valor;
    static int total;

    // Constructor
    Contador(int v = 0) : valor(v) {
        total++;
        cout << "Contador creado. total de Contadores = " << total << endl;
    }

    // Destructor
    ~Contador() {
        cout << "Contador destruido. valor = " << valor << endl;
    }

    // M茅todo para incrementar el contador de instancia
    void incrementar() {
        valor++;
    }
};

// Definici贸n e inicializaci贸n del miembro est谩tico
int Contador::total = 0;

int main() {
    // Crea varios objetos en el stack
    Contador c1(5);
    Contador c2(10);

    // Inspecciona con el depurador las direcciones de c1 y c2.
    // Observa que 'total' es compartido entre todos los objetos.

    c1.incrementar();
    c2.incrementar();

    cout << "c1.valor = " << c1.valor << endl;
    cout << "c2.valor = " << c2.valor << endl;
    cout << "Contador::total = " << Contador::total << endl;

    // Puedes tambi茅n crear un objeto din谩mico para comparar:
    Contador* c3 = new Contador(15);
    c3->incrementar();
    cout << "c3->valor = " << c3->valor << endl;

    // Coloca breakpoints en la creaci贸n de cada objeto y en las llamadas a 'incrementar()'
    // Observa c贸mo el miembro est谩tico 'total' se comparte y no se almacena en el stack de cada objeto.

    delete c3;
    return 0;
}
```

- Ejecuta el programa en modo depuraci贸n e inspecciona los valores y direcciones de c1, c2, c3.
- Observa el contenido de los objetos en memoria (Debug->Windows->Memory->Memory 1). Recuerda escribir la direcci贸n de memoria de cada objeto como `&c1` por ejemplo. 驴Puedes observar el valor de los miembros `valor` y `total`?
- 驴En d贸nde est谩 almacenado el miembro `valor` y el miembro `total` de la clase Contador?
- Selecciona `Contador::total` y presiona click derecho, luego selecciona "Add Watch". Esto te permite inspeccionar 
variables globales y puede ser de utilidad cuando investigues en los experimentos del curso.


**Reflexiona sobre lo siguiente**:

1. 驴Qu茅 puedes concluir de los miembros est谩ticos y de instancia de una clase en C++? 驴C贸mo se gestionan en memoria? 
驴Qu茅 ventajas y desventajas tienen? 驴Cu谩ndo es 煤til utilizarlos?
2. En el programa, en qu茅 segmento de memoria se est谩n almacenando c1, c2, c3 y Contador::total? Ten especial cuidado con la 
respuesta que das para el caso de c3, piensa de nuevo, qu茅 es c3 y qu茅 est谩 almacenando. Ahora, responde de nuevo, en qu茅 
segmento de la memoria se est谩 almacenando c3 y en qu茅 segmento de la memoria se est谩 almacenando el objeto al que apunta c3.

### Actividad 10

#### Explorando el ciclo de vida de un objeto

Realiza un experimento en el que crees un objeto dentro de un bloque de c贸digo y observa qu茅 ocurre al salir del bloque (uso del stack) en comparaci贸n con un objeto creado din谩micamente que persiste hasta que lo liberas.

``` cpp
#include <iostream>
using namespace std;

class Punto {
public:
    int x;
    int y;

    // Constructor
    Punto(int _x, int _y) : x(_x), y(_y) {
        cout << "Constructor: Punto(" << x << ", " << y << ") creado." << endl;
    }

    // Destructor
    ~Punto() {
        cout << "Destructor: Punto(" << x << ", " << y << ") destruido." << endl;
    }

    // M茅todo para imprimir valores
    void imprimir() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    {
        cout << "Inicio del bloque" << endl;
        Punto pBloque(100, 200);
        // Coloca un breakpoint aqu铆 para ver 'pBloque' en el stack.
        pBloque.imprimir();
    }
    // Al salir del bloque, el destructor de 'pBloque' se invoca.
    cout << "Fuera del bloque" << endl;

    // Creaci贸n din谩mica:
    Punto* pDinamico = new Punto(300, 400);
    pDinamico->imprimir();
    // 'pDinamico' sigue existiendo hasta que se libere manualmente.
    // Coloca un breakpoint aqu铆 y observa la direcci贸n de memoria.
    delete pDinamico;
    // Despu茅s de 'delete', el destructor se llama y la memoria se libera.

    return 0;
}
```

Ten presente que un bloque es un conjunto de instrucciones encerradas entre llaves `{}`.

- Ejecuta el programa en depuraci贸n paso a paso. No olvides colocar un breakpoint en la l铆nea 
`cout << "Inicio del bloque" << endl;`. 
- Inspecciona el ciclo de vida de pBloque (observa el constructor y el destructor al entrar y salir del bloque).
- Observa que el objeto creado din谩micamente no se destruye autom谩ticamente al salir del bloque, sino cuando se llama a delete.

**Reflexiona sobre lo siguiente**:

1. Explica el ciclo de vida de un objeto en el stack versus uno en el heap.

Ahora realiza la siguiente modificaci贸n:

``` cpp
#include <iostream>
using namespace std;

class Punto {
public:
    int x;
    int y;

    // Constructor
    Punto(int _x, int _y) : x(_x), y(_y) {
        cout << "Constructor: Punto(" << x << ", " << y << ") creado." << endl;
    }

    // Destructor
    ~Punto() {
        cout << "Destructor: Punto(" << x << ", " << y << ") destruido." << endl;
    }

    // M茅todo para imprimir valores
    void imprimir() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    {
        cout << "Inicio del bloque" << endl;
        Punto pBloque(100, 200);
        pBloque.imprimir();
        // Coloca un breakpoint aqu铆 para ver 'pBloque' en el stack.
    }
    // Al salir del bloque, el destructor de 'pBloque' se invoca.
    cout << "Fuera del bloque" << endl;
    // Creaci贸n din谩mica:
    Punto* pDinamico = new Punto(300, 400);
    pDinamico->imprimir();
    // 'pDinamico' sigue existiendo hasta que se libere manualmente.
    // Coloca un breakpoint aqu铆 y observa la direcci贸n de memoria.
    delete pDinamico;
    // Despu茅s de 'delete', el destructor se llama y la memoria se libera.

	{
		cout << "Inicio del bloque 2" << endl;
		Punto* pBloque2 = new Punto(500, 600);
		pBloque2->imprimir();
    }
    pBloque2->imprimir();
    delete pBloque2;

    return 0;
}

```

2. 驴Compila? 驴Por qu茅 ocurre esto? 
3. Modifica el programa para declarar `pBloque2` por fuera del bloque, pero inicializarlo dentro del bloque. 驴Qu茅 ocurre? 驴Por qu茅?

- En este caso:

``` cpp
#include <iostream>
using namespace std;

class Punto {
public:
    int x;
    int y;

    // Constructor
    Punto(int _x, int _y) : x(_x), y(_y) {
        cout << "Constructor: Punto(" << x << ", " << y << ") creado." << endl;
    }

    // Destructor
    ~Punto() {
        cout << "Destructor: Punto(" << x << ", " << y << ") destruido." << endl;
    }

    // M茅todo para imprimir valores
    void imprimir() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    {
        cout << "Inicio del bloque" << endl;
        Punto pBloque(100, 200);
        // Coloca un breakpoint aqu铆 para ver 'pBloque' en el stack.
        pBloque.imprimir();
    }

    Punto* pBloque2 = nullptr;
    {
        cout << "Inicio del bloque 2" << endl;
        pBloque2 = new Punto(500, 600);
        pBloque2->imprimir();
    }
    pBloque2->imprimir();
    delete pBloque2;

    return 0;
}

```

4. 驴Por qu茅 el objeto pBloque se destruye al salir del bloque y pBloque2 no?  
Recuerda de nuevo, pBloque2 es un objeto o es una referencia a un objeto?  
5. 驴En qu茅 parte de la memoria se almacena pBloque2?  
6. 驴En qu茅 parte de la memoria se almacena el objeto al que apunta pBloque2?

### Actividad integradora de aplicaci贸n

:::caution[ Bit谩cora - Actividad de transferencia y resoluci贸n de problemas]

**Contexto:**

Eres parte de un equipo de desarrollo de un motor para videojuegos. Un 
colega ha implementado una clase `Personaje` para gestionar los datos 
b谩sicos de los NPCs (Non-Playable Characters) en el juego, pero el programa 
est谩 fallando de formas impredecibles (crashes) y parece haber fugas de 
memoria (el juego consume cada vez m谩s RAM).

Se te ha encargado auditar la clase `Personaje`, identificar los problemas de 
gesti贸n de memoria y refactorizarla para que sea robusta y segura.

**C贸digo problem谩tico:**

```cpp
#include <iostream>
#include <string>

class Personaje {
public:
    std::string nombre;
    int* estadisticas; 

    Personaje(std::string n, int vida, int ataque, int defensa) {
        nombre = n;
        estadisticas = new int[3];
        estadisticas[0] = vida;
        estadisticas[1] = ataque;
        estadisticas[2] = defensa;
        std::cout << "Constructor: nace " << nombre << std::endl;
    }

    void imprimir() {
        std::cout << "Personaje " << nombre
            << " [Vida: " << estadisticas[0]
            << ", ATK: " << estadisticas[1]
            << ", DEF: " << estadisticas[2]
            << "]" << std::endl;
    }
};

void simularEncuentro() {
    std::cout << "\n--- Iniciando encuentro ---" << std::endl;
    Personaje heroe("Aragorn", 100, 20, 15);
    
    Personaje copiaHeroe = heroe;
    copiaHeroe.nombre = "Copia de Aragorn";

    std::cout << "Saliendo del encuentro..." << std::endl;
}

int main() {
    simularEncuentro();
    std::cout << "\nSimulaci贸n terminada." << std::endl;
    return 0;
}
```

**Tu tarea:**

1.  **Diagn贸stico del problema (an谩lisis):**

    *   Compila y ejecuta el c贸digo.
    *   Identifica y explica con detalle al menos **dos errores cr铆ticos** 
    de gesti贸n de memoria en la clase `Personaje` y su uso en 
    `simularEncuentro`.
    *   Para cada error, describe:
        
        * 驴Cu谩l es el error?   
        * 驴Por qu茅 ocurre? Explica el mecanismo a nivel de memoria 
        (stack, heap, punteros)
        * 驴Cu谩l es su consecuencia?

2.  Soluci贸n y refactorizaci贸n (s铆ntesis y creaci贸n):

    * Re-escribe la clase `Personaje` para que sea segura en cuanto a memoria. 
    Debes utilizar los conocimientos adquiridos en esta unidad y por tanto 
    tu soluci贸n no deber铆a usar la **Regla de los tres** que probablemente 
    sea la soluci贸n que te ofrezca una IA. 
    * Presenta el c贸digo completo de tu clase `Personaje` corregida.

3.  **Justificaci贸n de la Soluci贸n:**

Explica por qu茅 cada uno de los cambios que a帽adiste resuelven 
los problemas que diagnosticaste. 
:::

## Reflect: Consolidaci贸n y metacognici贸n 

### Actividad 11

#### Autoevaluaci贸n

El objetivo de esta actividad es que recuperes de tu memoria los conceptos fundamentales sobre manejo de 
memoria en C++ que exploraste en esta unidad. Al forzarte a recordar sin ver tus notas o buscar informaci贸n 
(pr谩ctica de recuperaci贸n), est谩s fortaleciendo las conexiones neuronales de ese conocimiento. Adem谩s, 
aplicar谩s estos conceptos a una situaci贸n nueva para evaluar tu capacidad de transferencia.

Ten presente que esta actividad la debes realizar m谩ximo en 1 hora 30 minutos, es decir, tambi茅n tendr谩s 
restricciones de tiempo.

:::caution[ Bit谩cora]

**IMPORTANTE**: Responde todas las preguntas sin consultar tus apuntes, c贸digo previo, internet o herramientas de 
IA. La meta es el esfuerzo por recordar y aplicar, no la perfecci贸n.

**Parte 1: recuperaci贸n de conocimiento (Retrieval Practice)**

1. Explica con tus propias palabras qu茅 es el stack y qu茅 es el heap en C++.

2. Describe las tres formas de pasar par谩metros a una funci贸n en C++ (valor, referencia y puntero). Para cada una, 
explica qu茅 sucede en memoria y cu谩ndo usar铆as cada m茅todo.

3. 驴Qu茅 diferencia hay entre una variable local, una variable global y una variable local est谩tica? 驴En qu茅 
segmento del mapa de memoria se almacena cada una?

4. Explica qu茅 es un objeto en C++ desde la perspectiva de memoria. 驴D贸nde se almacenan los miembros de 
instancia y d贸nde los miembros est谩ticos?

**Parte 2: transferencia y an谩lisis de situaci贸n nueva**

Imagina que trabajas en un equipo de desarrollo de videojuegos y tu compa帽ero te muestra este c贸digo 
problem谩tico que est谩 causando crashes en el juego:

```cpp
#include <iostream>
using namespace std;

class Enemigo {
public:
    static int totalEnemigos;
    int vida;
    int* armas;
    
    Enemigo(int v) : vida(v) {
        totalEnemigos++;
        armas = new int[3];
        armas[0] = 10; armas[1] = 15; armas[2] = 20;
    }
};

int Enemigo::totalEnemigos = 0;

void crearEscuadron() {
    for(int i = 0; i < 5; i++) {
        Enemigo soldado(100);
        soldado.vida -= 10;
    }
    cout << "Escuadr贸n creado. Total enemigos: " << Enemigo::totalEnemigos << endl;
}

int main() {
    crearEscuadron();
    crearEscuadron();
    return 0;
}
```

5. **An谩lisis de problemas**: identifica al menos dos problemas serios en este c贸digo relacionados con el manejo 
de memoria. Explica por qu茅 cada uno es problem谩tico.

6. **Predicci贸n de comportamiento**: 驴Qu茅 valor mostrar谩 `totalEnemigos` despu茅s de ejecutar el programa? 驴Por qu茅 ocurre esto?

7. **Propuesta de soluci贸n**: escribe una versi贸n corregida de la clase `Enemigo` que solucione los problemas identificados. 
Explica brevemente cada cambio que hiciste.

**Parte 3: reflexi贸n metacognitiva**

8. De todos los conceptos que exploraste en esta unidad (stack vs heap, paso de par谩metros, ciclo de vida de objetos, etc.), 
驴Cu谩l consideras que es el m谩s cr铆tico para evitar errores en programas reales? 驴Por qu茅?

9. 驴C贸mo cambi贸 tu comprensi贸n sobre lo que realmente es un "objeto" despu茅s de comparar C++ con C#? 驴Qu茅 implicaciones 
pr谩cticas tiene esta diferencia?

10. Si tuvieras que explicar a un compa帽ero de semestres anteriores por qu茅 es importante entender la gesti贸n de memoria 
en programaci贸n, 驴Qu茅 le dir铆as en m谩ximo 3 oraciones?
:::
